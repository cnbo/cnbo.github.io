[{"title":"学编程，先知规范","date":"2018-03-22T16:19:44.000Z","path":"2018/03/23/学编程，先知规范/","text":"像写好一篇文章一样写代码我相信一篇优秀的文章，一定是内容精彩，同时字迹漂亮，文章格式人性化。如果一篇文章的内容非常的不错，但是作者的字及其丑陋，同时文章的格式乱糟糟的。我相信那依然是一篇没人喜欢看的天书。写代码也是同样的道理，即使你的代码所实现的功能非常牛逼，但我们这些凡夫俗子都看不懂，那你的代码也没有多大的价值。 我为什么要写这篇博客写博客一直是我想去做的事，可是一直没有付诸于行动。虽然看别人的博客很容易，但当自己开始在键盘上敲打的时候，我发现太痛苦了。 2017 年 8 月初，和我同一批校招进厂的同学们都已上岗工作了。因为我们的水平不太统一，有的基础好点，有的基础差点，所以老大每周会给我们布置作业，同时也会对我们的作业进行讲评。经过最近两次作业，我发现有部分同学的编码规范有待提高。其实这也可以理解，因为他们之前没有接触过，在学校的时候也没人告诉他们编码要讲究规范。 我是四月份进的厂，老大安排我维护两个系统。当我看见系统的源码的时候，我的心里有着一万匹叫做曹里的马在奔腾。包含几百行代码的方法随处可见；一个方法有几十个形式参数是正常现象；各种代码风格混杂在一起特别杀马特；在 JSP 里掺杂着 Java、JS、HTML、CSS 代码，有种 56 个民族一家亲的味道；整个系统有一半的逻辑是写在存储过程里的，先喝口水压压惊。 其实公司老系统代码令人恶心的一个很重要的原因就是上梁不正，下梁歪。由于刚进来的新人也不分不清代码风格的好坏，他们只能学着前人的风格。这样的恶性循环非常可怕。我希望所有学习编程的同学，从开始就养成一个非常好地编码习惯。 高级程序语言诞生的目的我们现在接触到的绝大多数编程语言都是高级语言，例如： C、C++、Java、JavaScript 等。我们在这里不论各种高级程序语言的优劣。 我们一定要铭记，用高级语言写出来的代码是给人看的。我相信高级语言诞生时最宏伟的一个目标就是：即使没有学过编程的人，他们可以通过类名、方法名和变量名大概知道程序的功能。 像写好一篇文章一样写代码我相信一篇优秀的文章，一定是内容精彩，同时字迹漂亮，文章格式人性化。如果一篇文章的内容非常的不错，但是作者的字及其丑陋，同时文章的格式乱糟糟的。我相信那依然是一篇没人喜欢看的天书。写代码也是同样的道理，即使你的代码所实现的功能非常牛逼，但我们这些凡夫俗子都看不懂，那你的代码也没有多大的价值。 我们简单看一下写出好代码要掌握哪些规范： 每个方法所能容纳的代码行数不要超过 30 行，一行代码的字符数量控制在 120 以内。 一个方法只做一件事， 就好比我们在家只吃饭，却不做饭。 在给类名、方法名和变量命名时尽量做到见名知意，这会比你们的注释更加给力，因为这时你们的代码自带注释功效。 类名的每个单词的首字母大写；方法名和变量名的第一个单词的首字母小写，后面单词的首字母大写，这就是传说中的驼峰命名法；常量名的所有字母都要大写，并且每个单词间用下划线隔开。 如果一个方法的形式参数中有太多的基本类型，或者数量超过了 5 个，这时你可以将这些参数封装成一个类。 当一个方法的逻辑比较复杂的时候，一定要加上注释；给类加上注释，以阐明一个类有哪些功能。 我们也是自己嘴中的那个坑货如果你们觉得养成良好的编码习惯并不重要，或者是很难。那么你们可以时隔一个月、半年或者一年再去看你们之前写过的代码，我相信你们会喷嚏连连，因为你们会骂这是哪个傻*写的，很不幸那个傻坑货就是你们自己。 不要抱着侥幸的心态，自以为只要是自己写的代码自己就能看懂。其实，你们写的代码并不是你们自己的，随着时间的推移，你们的代码就是别人的啦。为了不让别人(包括你们自己)在背后骂你们，一定要养成良好的编码习惯。 总结我在文章中并没有详细地列举具体地编码规则，因为这些规则已经有人给出来了。阿里巴巴为我们贡献了一套 Java 开发规范，这套规范不仅适用于 Java 开发，同样对其他的编程开发有借鉴意义。这里是阿里巴巴 Java 开发手册的下载地址。[PS： 阿里巴巴的 Java 开发团队是国内最牛逼的] 最后我给大家推荐一本非常好的书[编写可读代码的艺术]，它会教你如何写出一手漂亮的代码，在书中有各种编程语言的实例。","tags":[{"name":"编程规范","slug":"编程规范","permalink":"http://yoursite.com/tags/编程规范/"}]},{"title":"设计模式笔记——观察者模式","date":"2018-03-22T16:00:01.000Z","path":"2018/03/23/设计模式笔记——观察者模式/","text":"什么是观察者模式（Observer Pattern）观察者模式定义了对象之间的一对多依赖。这样一来，当一个对象状态改变时它的所有依赖者都会收到通知并自动更新。 什么是观察者模式（Observer Pattern）观察者模式定义了对象之间的一对多依赖。这样一来，当一个对象状态改变时它的所有依赖者都会收到通知并自动更新。 观察者模式的应用观察者模式的应用很广泛。例如在 Android 开发时需要对控件注册事件监听，控件属于被观察者，在该控件上所注册的事件属于观察者，当控件发生变化时相应的监听事件会立即做出回应。我想大家都有自己喜欢的微信公众号，其实微信公众号的订阅、推送很好的体现了观察者模式。当我们想及时获得自己喜欢的公号的更新就得先关注它，然后公号有更新时会第一时间通知它的每一位仰慕者。设计模式来源于生活，细细品味生活能够更好的去理解设计模式。 观察者模式所涉及的 OO 设计原则 实现交互对象之间的松耦合。 何为对象之间的松耦合？松耦合就是两个对象可以交互，但是不太清楚彼此的细节。更通俗一点来说就是你和你的手机就是松耦合的，你可以很轻松的玩耍你的手机（你和手机进行者交互），但你并知道手机内部的实现，手机也更不知道使用者是谁啦。 封装变化。 多用组合，少用继承。 针对接口编程，不针对实现编程。 观察者模式 Java 代码实现及分析 分析 此 Demo 借用模拟微信公众号简单地实现了观察者模式。 WeChatPublicNumber 是所有微信公众号的公共接口，所有具体的微信公众号都要实现此接口，CnboJavaDev 就是一个实现此接口的微信公众号（我决定了，我以后的微信公众号就叫此名了，嘻嘻）。WeChatPublicNumber 提供了用户订阅 registerUser(User user) 和取消订阅的方法 removeUser(User user)，还有推送更新的方法 notifyUsers()。 User 是所有用户的公共接口，此接口提供了更新方法 update() 和文章阅读方法 readArticle() (此方法主要用来测试打印)。Facebook 和 Google 实现了 User 接口。 TestObserver 用于对此 Demo 的测试。 Demo 的 UML 类图 WeChatPublicNumber.java 1234567891011//WeChatPublicNumber(微信公众号接口)public interface WeChatPublicNumber &#123; //用户订阅公号 public void registerUser(User user); //用户取消订阅 public void removeUser(User user); //向所有订阅用户推送更新 public void notifyUsers();&#125; Article.java 1234567891011121314151617181920212223242526272829//文章(别乱想哦)public class Article &#123; //文章的标题 private String title; //文章的作者 private String author; public String getTitle() &#123; return title; &#125; public void setTitle(String title) &#123; this.title = title; &#125; public String getAuthor() &#123; return author; &#125; public void setAuthor(String author) &#123; this.author = author; &#125; @Override public String toString() &#123; return \"title:\" + title + \"; author:\" + author; &#125;&#125; User.java 123456//微信用户接口public interface User &#123; public void update(Article article); public void readAritcle();&#125; CnboJavaDev.java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546//CnboJavaDev 是一个实现了接口 WeChatPublicNumberpublic class CnboJavaDev implements WeChatPublicNumber &#123; private Article article; private List&lt;User&gt; users; public CnboJavaDev() &#123; users = new ArrayList&lt;&gt;(); &#125; @Override public void registerUser(User user) &#123; if (users != null) &#123; users.add(user); &#125; &#125; @Override public void removeUser(User user) &#123; if (users != null &amp;&amp; users.contains(user)) &#123; users.remove(user); &#125; &#125; //发布文章 public void publishArticle() &#123; notifyUsers(); &#125; //向所有订阅者推送文章 @Override public void notifyUsers() &#123; if (users == null) &#123; return; &#125; for (User user : users) &#123; user.update(article); user.readAritcle(); &#125; &#125; public void addArticle(Article article) &#123; this.article = article; publishArticle(); &#125;&#125; Facebook.java 1234567891011121314151617181920//微信用户 Facebookpublic class Facebook implements User &#123; private Article article; private WeChatPublicNumber weChatPublicNumber; public Facebook(WeChatPublicNumber weChatPublicNumber) &#123; this.weChatPublicNumber = weChatPublicNumber; weChatPublicNumber.registerUser(this); &#125; @Override public void update(Article article) &#123; this.article = article; &#125; @Override public void readAritcle() &#123; System.out.println(\"facebook read \" + article); &#125;&#125; Google.java 1234567891011121314151617181920//微信用户 Googlepublic class Google implements User &#123; private Article article; private WeChatPublicNumber weChatPublicNumber; public Google(WeChatPublicNumber weChatPublicNumber) &#123; this.weChatPublicNumber = weChatPublicNumber; weChatPublicNumber.registerUser(this); &#125; @Override public void update(Article article) &#123; this.article = article; &#125; @Override public void readAritcle() &#123; System.out.println(\"google read \" + article); &#125;&#125; TestObserver.java 123456789101112131415161718192021222324//测试观察者模式public class TestObserver &#123; public static void main(String[] args) &#123; CnboJavaDev cnboJavaDev = new CnboJavaDev(); //facebook 和 google 关注了 cnboJavaDev（如果我真被 facebook 和 google //关注了，那我会兴奋成神经的，哈哈） User facebook = new Facebook(cnboJavaDev); User google = new Google(cnboJavaDev); Article article1 = getArticle(\"学习笔记之单例设计模式\", \"cnbo\"); //cnboJavaDev 发布一篇新文章 article1，同时 facebook 和 google //都接收到了更新，然后他哥俩有滋有味的读者cnbo的文章。 cnboJavaDev.addArticle(article1); Article article2 = getArticle(\"学习笔记之策略设计模式\", \"cnbo\"); cnboJavaDev.addArticle(article2); &#125; public static Article getArticle(String title, String author) &#123; Article article = new Article(); article.setTitle(title); article.setAuthor(author); return article; &#125;&#125;","tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/设计模式/"}]},{"title":"设计模式笔记——策略设计模式","date":"2018-03-22T15:51:11.000Z","path":"2018/03/22/设计模式笔记——策略设计模式/","text":"策略设计模式（Strategy Pattern）：定义了算法族，分别封装起来，让他们之间可以互相替换，此模式让算法的变化独立于使用算法的客户。其实策略设计模式的核心就是多态（变量的声明是一个超类型，通常是一个抽象类或一个接口，在程序运行时根据情况选择具体要执行的行为。） 什么是策略设计模式策略设计模式（Strategy Pattern）：定义了算法族，分别封装起来，让他们之间可以互相替换，此模式让算法的变化独立于使用算法的客户。其实策略设计模式的核心就是多态（变量的声明是一个超类型，通常是一个抽象类或一个接口，在程序运行时根据情况选择具体要执行的行为。） 策略模式的应用 多个类拥有相同的方法，但具体的实现方式不同，在运行时动态地选择具体要执行的行为。 需要在不同情况下使用不同策略（算法），或则策略在未来还可能使用其他方式实现。 对客户隐藏具体策略的实现细节，彼此完全独立。 策略设计模式涉及的 OO 设计原则 找出应用中可能需要变化之处，把他们独立出来，不要和那些不需要变化的代码混在一起。 针对接口编程，而不是针对实现编程。 “ 针对接口编程”真正意思是“针对超类型编程”，关键就在多态。 多用组合，少用继承。 策略模式 Java 代码实现及分析 Demo 的 UML 图 ProgrammingLanguage.java 123public interface ProgrammingLanguage &#123; public void program();&#125; Java.java 123456public class Java implements ProgrammingLanguage &#123; @Override public void program() &#123; System.out.println(\"use java programming\"); &#125;&#125; JavaScript.java 123456public class JavaScript implements ProgrammingLanguage &#123; @Override public void program() &#123; System.out.println(\"use JavaScript programming\"); &#125;&#125; ObjectC.java 123456public class ObjectC implements ProgrammingLanguage &#123; @Override public void program() &#123; System.out.println(\"use ObjectC programming\"); &#125;&#125; Programmer.java 12345678910111213public abstract class Programmer &#123; ProgrammingLanguage language; public void performProgram() &#123; language.program(); &#125; //动态地指定程序员所使用的编程语言，比如java程序也也需要使用JavaScript编写程序 public void setProgrammiingLanguage ( ProgrammingLanguage language) &#123; this.language = language; &#125;&#125; JavaProgrammer.java 123456public class JavaProgrammer extends Programmer &#123; //构造Java程序员时预指定其所擅长的编程语言 public JavaProgrammer(ProgrammingLanguage language) &#123; this.language = language; &#125;&#125; JavaScriptProgrammer.java 123456public class JavaScriptProgrammer extends Programmer &#123; //在构造JavaScript程序员时预指定其所擅长的编程语言 public JavaScriptProgrammer(ProgrammingLanguage language) &#123; this.language = language; &#125;&#125; 分析此 Demo 简单的实现了策略设计模式。实现的代码我已经在上面贴出，现在我说说代码背后的故事。 我是如何实现“针对接口编程”的Programmer 是将 performProgram() 的实现委托给接口 ProgrammingLanguage 的，而不是直接委托给 ProgrammingLanguage 的实现类。Programmer 的子类并不用关心 ProgrammingLanguage 的子类是如何实现的，他们之间是松耦合的。 我是如何实现“封装变化”的Programmer (程序员)使用那一种 language (编程语言)编程是不确定的，是可以动态变化的。所以我将具体的编程方法 program() 封装在了 ProgrammingLanguage 中了，即 Programmer 中performPrograme() 的具体执行是 language.program()。由于 language 是一个接口类型的引用变量，所以 Programmer 的子类在程序运行过程中通过 setProgrammingLanguage 方法动态改变真正要使用的 ProgrammingLanguage 的实现类。 我是如哦哦和实现“多用组合，少用继承”的由于 Programmer 使用的 language 是动态变化的，所以我在 Programmer 声明了一个接口类型的引用变量 language，而不是选择在 Programmer 的子类中通过实现各种接口获得使用某种编程语言的能力。","tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/设计模式/"}]},{"title":"设计模式笔记——单例设计模式","date":"2018-03-22T15:22:34.000Z","path":"2018/03/22/设计模式笔记——单例设计模式/","text":"单例模式的应用场景：线程池（Thread Pool）、缓存（Cache）、对话框、处理偏好设置、注册表（Registry）对象，日志对象，充当打印机、显卡等设备的驱动程序的对象。这类对象只能有一个对象，如果出现多个实例就会导致很多问题，例如：程序的行为异常、资源使用过量、或者是出现不一致的结果。 什么是单例模式（Singleton Pattern）单例模式确保一个类只有一个实例，并提供一个全局访问点。 单例模式的应用场景实现一个单例模式很简单，但我没有想过单例模式有什么用处，直到一次笔试就遇到了问单利模式的应用场景有哪些。 单例模式的应用场景：线程池（Thread Pool）、缓存（Cache）、对话框、处理偏好设置、注册表（Registry）对象，日志对象，充当打印机、显卡等设备的驱动程序的对象。这类对象只能有一个对象，如果出现多个实例就会导致很多问题，例如：程序的行为异常、资源使用过量、或者是出现不一致的结果。 Java 代码实现单例有四种方式实现单例模式，分别是：饿汉式、懒汉式、双重检查加锁、枚举。接下来我会结合代码介绍这四种方式。 饿汉式在类被加载时就在类中创建一个唯一实例。优点：线程安全。代码实现： 12345678910111213//单例模式（饿汉式实现）public class Singleton1 &#123; //定义一个静态的Singleton1实例 private static final Singleton1 singleton = new Singleton1(); //私有化构造函数以致外部无法创建 Singleton1 实例 private Singleton1() &#123;&#125; //提供一个静态方法供外部使用 Singleton1 实例 public static Singleton1 getInstance() &#123; return singleton; &#125;&#125; 懒汉式在类首次被使用时才创建处一个全局唯一的实例。缺点：线程不安全。代码实现： 12345678910111213141516// 单例模式（懒汉式实现）public class Singleton2 &#123; private static Singleton2 singleton; //私有化构造函数 private Singleton2() &#123;&#125; public static Singleton2 getInstance() &#123; //判断 singleton 是否为 null,如果为 null 则创建，否则直接返回 if (singleton == null) &#123; singleton = new Singleton2(); &#125; return singleton; &#125;&#125; 双重检查加锁双重检查加锁是对饿汉式在多线程环境下的升级，保证其线程安全。之所以在代码中是用双检查是为了确保只有在第一次创建实例时才会使用同步，因为同步非常的耗资源。代码实现： 12345678910111213141516171819// 单例模式（线程同步实现）public class Singleton3 &#123; private static Singleton3 singleton; private Singleton3() &#123;&#125; public static Singleton3 getInstance() &#123; //双重检查加锁 if (singleton == null) &#123; synchronized(Singleton3.class) &#123; if (singleton == null) &#123; singleton = new Singleton3(); &#125; &#125; &#125; return singleton; &#125;&#125; 枚举枚举是最优雅的实现单例的方式。饿汉式、懒汉式、双重检查加锁都有一个共同 的问题，那就是都可以通过反射机制调用私有构造器创建实例，这样就不能保证实例是唯一的，这有背单例的使命了。同时枚举也是线程安全的。代码实现： 1234// 单例模式（枚举实现）public enum Singleton4 &#123; INSTANCE;&#125; 是不是觉得枚举实现单例的代码太简单了，我想说的是，枚举就是这么任性，就是要这么简单。 FAQ 为什么全局变量比单例模式差全局变量基本上是对对象的静态引用。在这样的情况下使用全局变量非常耗资源。同时使用全局变量不能确保只有一个实例。 单例类能否被继承无论是枚举实现还是非枚举实现，单例类都不能被继承。非枚举方式实现的单例类由于构造器是私有的，因而不能被继承。 单例是否违背例 OO 设计答案是肯定的。单例类不只负责管理自己的实例，同时还在应用程序中担任角色。虽然单例违背例 OO 设计，但它让整体设计变得简单，这是可以谅解的。 有多个类加载器的情况下如何处理单例类自行指定类加载器，并指定同一个类加载器。","tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/设计模式/"}]},{"title":"小白和老妈聊计算机组成原理","date":"2018-03-21T15:56:20.000Z","path":"2018/03/21/小白和老妈聊计算机组成原理/","text":"这段时间看完了 《编码的奥秘》和 《程序是怎样跑起来的》这两本书，我想尝试用大白话聊聊计算机组成原理。在 《程序是怎样跑起来的》 这本书中，有几个故事片段：向小学生讲解 CPU 和二进制、向沉迷游戏的中学生讲解内存和磁盘、向喜欢玩手机的女高中生讲解操作系统的作用、向邻居老太太说明显示器和电视机的不同。我觉得作者的想法太棒了，将晦涩难懂的计算机知识以通俗的方式讲解给不太了解计算机知识的人，这样不仅有利于我们自己对计算机的理解，同时也能让更多的人了解计算机知识。 前言 这段时间看完了 《编码的奥秘》和 《程序是怎样跑起来的》这两本书，我想尝试用大白话聊聊计算机组成原理。在 《程序是怎样跑起来的》 这本书中，有几个故事片段：向小学生讲解 CPU 和二进制、向沉迷游戏的中学生讲解内存和磁盘、向喜欢玩手机的女高中生讲解操作系统的作用、向邻居老太太说明显示器和电视机的不同。我觉得作者的想法太棒了，将晦涩难懂的计算机知识以通俗的方式讲解给不太了解计算机知识的人，这样不仅有利于我们自己对计算机的理解，同时也能让更多的人了解计算机知识。 在个人计算机和智能手机泛滥的现在，依然有很多人不了解计算机，即使他们每天都在使用他们。像我这样计算机专业的学生要不是恶补计算机组成原理，可能对计算机也是个模糊的概念。然后就是有很多人并不清楚程序员的工作到底是什么，尤其是我们的上一辈。受到 《程序是怎样跑起来的》 一书的启发，我将模拟和老妈的对话来聊计算机组成原理。我老妈没有接受过多少教育，我将会用生活中的一些普通事务来给她讲解计算机。计算机的出现是为了解决生活中的问题，让机器去做本该人去做的事，那么，用生活中的事务来类比计算机的组成和运行原理应该是行得通的。 小白是我一同学以牙还牙给我的外号，我觉得这外号太赞了，因为我在技术上是个小白。 小白和老妈的聊天记录 老妈: 儿子，你能给老妈讲讲你的工作具体是干什么的吗？ 小白: 妈，您也这太难为我了吧，即使给您了说了，您也不懂啊！ 老妈: 儿子，你不说，怎么就知道我不懂呢？如果你不能将自己所学的知识讲给别人听，你又怎么知道自己是否真正理解了学习过的知识。 小白: 还是老妈您厉害，说的太有道理了。容我先想想如何给您介绍我的工作。 旁白: 老妈不仅不会计算机，也没上过几年学，要向她介绍程序员的工作和计算机，这任务难度可不小啊。但是再难，也得想办法让老妈听懂，毕竟我出生的时候既不会说话，也不会走路，因为老妈的细心教导，我才学会了说话、走路。 思考中…… 小白: 老妈，我的工作是和计算机打交道，您知道您每天都在使用计算机吗？ 老妈: 不对啊，你在学校学的不是电脑吗，怎么是和计算器打交道呢？ 小白: 哈哈，您真幽默！我来慢慢给您解释。我们平常生活中所说的计算机，一般是指计算器，用来在购买商品时计算价钱用的。而我现在说的计算机不是用来做简单算术的计算器，我所说的计算机就是您给我买的电脑。严格来说，您给我买的电脑叫做个人计算机，是计算机的一种。电脑是我工作的工具。 计算器计算机 老妈: 你这信息量有点大，你老妈我有点懵。你能讲讲那计算器，哦，不对，就是你那计算机到底是个什么玩意，你又是如何用它来工作的，你的工作内容又是什么？ 小白: 老妈，您先别急，容我给您细细道来。为了不让您犯糊涂，接下来我会将计算机说成电脑。您是否记得，家里每次卖棉花的时候，老爸都会将每一包棉花的重量记录在本子上，最后一通加减乘除计算出棉花值多少钱，与老爸一起计算价钱的还有收棉花的商人，不过商人使用的是计算器。老爸需要知道加减乘除是怎么回事，他才能计算出最终的结果，而商人只需要将数据输入到计算器中，然后计算器就会告诉商人正确的结果。在这个过程中，商人并不需要自己会加减乘除，他只需要学会使用计算器就好了。通过这个故事您是否发现，计算器做了一部分本应该是人该做的事，而我们只要把数据给计算器，计算器就会返回一个结果给人，我们并不需要关心计算器是如何做到的。您是不是觉得计算器很聪明呢？ 老妈: 按你这么说，计算器确实很聪明。但是，儿子，你想通过这个故事说明什么呢？ 小白: 其实计算器本来并不知道如何进行加减乘除操作的，是我们告诉计算器如何进行加减乘除的。我想您现在应该对我的工作有点模糊的概念了，我的工作就是告诉计算器和电脑这些机器如何帮助我们人类做事。 老妈: 那你又是如何教它们做事的呢？ 小白: 这是个好问题，告诉您一个秘密，我会和电脑说话，哈哈。。。 老妈: 你这臭小子，净瞎扯，那你和电脑说个话给我看看。 小白: 我没瞎扯，我确实会和电脑说话，只是不能像我和您这样人类的语言非常流畅地聊天。电脑要听懂我的话要经历一个非常复杂的过程。要想把这个复杂的过程说清楚，可能会很难，您还想继续听我瞎扯下去吗？ 老妈: 你少废话，这好不容易听到有意思的地方了，你就想吊我胃口然后跑路，想得美，继续你的表演。 小白: 好的，小的遵命。我想告诉您，电脑和我们人一样，它们也有自己的语言。 老妈: 哇，这么神奇！那它们的语言是什么呢？ 小白: 它们的语言就是 0 和 1，您如果要和它们聊天，那么就是您吧啦吧啦地说一连串的 0 和 1，然后它们也用一连串的 0 和 1 回应您。估计您现在又在犯愁了。 老妈: 确实犯愁，那它们是如何用 0 和 1 来传达信息的？ 小白: 不愧是我亲妈，问的问题越来越有深度了。您可不要小看这简单的 0 和 1，它们可是很强大的。我们先从硬币说起，一枚硬币有两面，一面是有花的，一面是有字的。那么电脑是如何形容硬币的两面的呢？您要记住，电脑只会说 0 和 1。 老妈: 我是这么想的，也不知道对不对，电脑应该是用 0 表示硬币带花的一面，用 1 表示带字的一面。 小白: 此处应有掌声，老妈简直太棒了。那我们现在来一个稍微复杂点的，您不是经常找好友们打打麻将吗，你们需要用骰子来确定从哪里开始起牌。那我们现在就要用这骰子来搞事情。骰子有六面，它们分别表示 1、2、3、4、5、6 这六个数字，现在让我们来想想电脑是如何用 0 和 1 来表示这六个数的呢？ 老妈: 这我就猜不到了。 小白: 没事，让我来为您揭开谜底，咱们先看下面这张表格。 电脑是如何表示骰子的六个面的是不是很神奇，电脑竟然能用 0 和 1 的组合来表示骰子的六个面。老妈: 难道电脑只能用 0 和 1 来表示 6 以内的这些简单数字吗？小白: 当然不只这些简单的数字啦，如果想要表示更大的数字，就需要更长的 0 和 1 的组合。我们现在没有必要去深究如何用 0 和 1 表示更复杂的数字，因为这已经超出了您所能承受的范围，您只要知道电脑能用 0 和 1 来表示我们生活中的数字就行了。老妈: 难道电脑就只能用 0 和 1 表示数字吗？小白: 那肯定不是啦，让我再来为您举个例子。用 0 和 1 给小朋友起名字您看，上图的表格张有四个小朋友的名字，现在我用 0 和 1 给他们分别起了一个新名字，让电脑能够认识这些可爱的小家伙们。通过这三个例子，我们可以发现，我们可以用 0 和 1 表达任何信息。关于 0 和 1 的故事还有更加复杂的，我们就不再追究了，重要的是我们知道 0 和 1 是电脑的语言。『注: 如果大家想了解更多 0 和 1 的故事，可以细细品尝 《编码的奥秘》这本书。』老妈: 儿子，你能讲讲为什么电脑的语言是 0 和 1 吗？小白: 妈，咱先来个抱抱，您的问题越来越有深度了，我当然乐意给您讲讲为什么了。您知道为什么电脑叫电脑吗？老妈: 不知道。。。小白: 因为电脑确实有一个大脑，让我们先看看它长啥样。![计算机的大脑——西皮柚 (CPU)]计算机的大脑——西皮柚(CPU) 老妈: 这就是电脑的大脑了呢？可别糊弄我哦。 小白: 哪敢糊弄您啊，这确实就是电脑的大脑了。您可别看它长得如此秀气，它的内部结构复杂到您无法想象，而且功能非常强大。 老妈: 那怎么称呼它呢？ 小白: 它叫西皮柚 ( CPU——Central Processing Unit)，是不是听着像是某种柚子的名字。 老妈: 这名字有点意思。你这说了老半天，似乎还没进入正题啊。 小白: 别急嘛，咱得一个萝卜一个坑，循序渐进地深入。您别听我说它内部非常的复杂，就觉得它深不可测了，再高的大楼都是由一块块的砖头堆积起来的，其实西皮柚的内部是由无数个开关(晶体管)组成的。 老妈: 由开关组成的？ 小白: 是的，就是由开关组成的。您完全可以把它理解成我们家里点灯的开关，现在是不是觉得很神奇呢？ 老妈: 确实很神奇，太意外了。 小白: 我们现在已经接触到真相了。我们在使用开关控制灯的时候，永远只有两种状态，要么是关灯，要么是开灯，觉不会有第三种情况。 老妈: 这不就和硬币的正反面是一个道理么。 小白: 是的。之所以电脑的语言是 0 和 1，就是因为西皮柚是由开关组成的，一个开关永远只有两种状态，我们可以用 0 和 1 来表示开关的状态。虽然一个开关只有两种状态，但很多个开关连接起来就可以有很多状态了，也就是可以组成很多 0 和 1 了，也就意味着可以表示很多复杂的信息了。 老妈: 既然我们现在知道电脑的语言是 0 和 1 了，那你是如何与它交流的呢？ 小白: 因为我和电脑之间用的是两种不同的语言，所以这个交流的过程非常曲折。让我们先来看看生活中的电脑是由那几部分组成的。 笔记本 台式电脑上面两张图是我们生活中所能接触到的电脑，左图我们称之为笔记本，右图我们称之为台式电脑，从图中我们可以看出，它们都有一个键盘、一个鼠标和一个显示器。 老妈: 右图中不是还有一个大黑箱子吗，那个黑箱子是什么东西，为什么笔记本没有呢？ 小白： 那个大黑箱子才是真正的宝贝啊，值钱的东西可都在里面啊，西皮柚可就藏在那里面，那些什么键盘啊，鼠标都是些配角。其实笔记本也有那黑箱子，只是它体积变小了，而且位置稍微有点不起眼，笔记本的黑箱子就在键盘的底下。 老妈: 既然显示器和键盘是配角，那他们的作用是什么呢？ 小白: 键盘是一个输入设备，我们通过键盘将我的话和数据告诉电脑；显示器是一个输出设备，我们可以通过显示器看到电脑给我们反馈的结果。输入和输出设备还有很多，比如话筒 (输入设备)、音响 (输出设备)等等。我们接着来看一下我和电脑交流的简要过程图。 小白和电脑交流的过程通过上面的图，我们可以发现，其实我和电脑交流，本质上是和它的西皮柚交流。 老妈: 怎么图中还有一个翻译官？ 小白: 翻译官可是我大爷啊，要是没它，我和电脑就只能大眼瞪小眼了。我说的是为计算机定做的英语，也就是我常说的编程语言，电脑说的是 0 和 1，这压根没法交流。 老妈: 那你就不能去学习用 0 和 1 说话么？ 小白: 您也知道，您儿子没啥别的特点，就是懒。电脑那 0 和 1 的语言太难了，对于我来说和天书没差别。我们这世界很有意思的一个地方就是：除了有像我这种非常懒得人，也有非常勤劳和充满智慧的人。有一群被我试做为神的人，他们不仅精通编程语言，还精通电脑的0 和 1，他们可以用 0 和 1 愉快地和电脑聊天。因为那些人毕竟是少数，所以他们为了方便跟多的人于电脑进行交流，他们就制作了一个翻译官，将其放置在电脑的内部，这个翻译官能够将编程语言翻译为电脑能够理解的 0 和 1。 老妈: 你这臭小子，多花点时间跟那些大牛们学学，别每天只知道吃喝玩乐。那我看见你每次用电脑和同学聊天或者是看电影，也没输入什么编程语言啊。 小白: 您这各个问题都能命中要害，真棒！老妈，我在工作中是教电脑如何做事，而在生活中我是使唤电脑做事。如果我每次使唤电脑做事的时候，我还要去教电脑如何做事，估计会有好多人会和我上街去乞讨，有些人会砸了电脑然后去做些不理智的事。 老妈: 按你这么说，电脑它能记住你教它做的事吗？ 小白: 那必须的啊，不然为啥它叫电脑呢，记忆功能那是必须有的。 老妈: 你是说那个什么西皮柚还有记忆功能？ 小白: 关于记忆这事，那可不敢劳烦它老人家，它是只要没电了，就会停止工作，然后忘掉所有的事情。 老妈: 你这小子，葫芦里还有啥宝贝，别藏着掖着了。 小白: 无图无真相，我们来看看电脑的那个黑箱子除了西皮柚子还有些啥玩意儿。 电脑的关键组成部分老妈: 这图里面都是些啥东西啊？ 小白: 我之前不是说电脑能记住我教它做的事么，电脑很聪明，它把学会的事情都记忆在那个叫做硬盘的设备中了。当我告诉电脑我要听歌时，电脑就从硬盘那找播放音乐的技能。在硬盘中不仅可以存储电脑学会的各种厉害的技能，还可以存储我收藏的视频、音乐、图片和书籍等等，它可以存储很多东西。说白了，硬盘就是电脑中的一个仓库。 老妈: 既然硬盘是仓库，那图中其它几个东东又是干什么的呢？ 小白: 其实内存、西皮柚缓存和寄存器也是用来存储东西的。 老妈: 为什么需要这么多存储设备呢？它们之间有什么差别吗？ 小白: 因为西皮柚在做一件事情的时候，它不能直接从硬盘那个家伙那里直接获取数据。 老妈: 为什么呢？ 小白: 想要知道为什么，您先得回答我几个问题。 老妈: 好，继续你的表演。 小白: 您平时买东西是用什么付款？ 老妈: 晕，当然是钱啊！ 小白: 我的意思是，您出门在外，钱是放在哪里的。 老妈: 钱包啊。 小白: 您每天出门前似乎都会检查下钱包是否弹药充足，对吧。那您是如何保证每天出门时钱包都是元气满满的呢？ 老妈: 家里有保险柜啊，没钱了就从那拿就行了。 小白: 原来家里还有保险柜啊，那密码是多少？ 老妈: 你这臭小子绕来绕去，就是为了打听这事啊，没门儿！ 小白: 您老放心，我老板每个月都会按时给我发生活费，压根不会对您的小金库有什么非分之想。 老妈: 那就好，继续说正事。 小白: 那如果家里的保险柜快断粮了呢？ 老妈: 那当然是赶快去离得最近的取款机取钱啊。 小白: 那取款机没钱了怎么办？ 老妈: 那必须马上告知银行，让他们从金库运点钱过来让取款机吃饱喝足。你这问了半天，想表达什么呢？ 小白: 其实就在咱俩这一唱一和的过程中，我已经给您大概解释了下硬盘、内存、西皮柚缓存和寄存器它们之间的关系。 老妈: 有吗？ 小白: 必须的啊。我们先来看个表格。!内存设备和存钱设备的对应关系老妈: 我没看懂你这表格表达的意思。 小白: 您购物需要钱，这钱来自于您的钱包，而您钱包中的钱来自于家里的保险柜，保险柜中的钱来自于取款机，取款机中的钱来于银行的金库。电脑给我播放视频也是同样的道理，首先西皮柚会从寄存器获取相关的数据，而寄存器中的数据来自于西皮柚缓存，西皮柚缓存中的数据来自于内存，内存中的数据来自硬盘。 老妈: 我还是没想明白为什么需要这么复杂的过程。 小白: 之所以会有这么多中间过程，都是因为有个时间效率在从中作梗。老妈: 怎么说。 小白: 您为什么在购物的时候，不是直接从银行的金库取钱来付款？ 老妈: 要是我买个东西，还得先走个几天几夜去银行金库取钱，那还得了。嗯，我似乎明白了点什么。 小白: 其实我说了半天，就是想说，硬盘虽然能装很多东西，但别人从那取数据非常的耗时，而西皮柚做事又麻利，效率非常之高，您要是让西皮柚直接从硬盘那取数据的话，那西皮柚半天都做不完一件事。所以，要想充分利用西皮柚做事的效率，我们就为西皮柚准备了寄存器，寄存器存取数据的速度非常之快，深受西皮柚的喜爱，所以西皮柚是直接从寄存器获取数据。但是了，人无完人，金无足赤，寄存器虽然读取数据的速度很快，但它是以牺牲存储容量为代价的。所以，我们又为寄存器准备了西皮柚缓存，西皮柚缓存读取数据的速度要比寄存器慢点，但它的存储容量要比寄存器大。毕竟西皮柚缓存的容量也是有限的，还是不能满足需求，那么我们又在西皮柚缓存和硬盘之间加了一个内存，内存的读取速度和存储容量刚好介于西皮柚缓存和硬盘之间。 老妈: 儿子，你说了这么一大堆，是不是想表达为了匹配西皮柚的工作效率，需要对西皮柚的数据做一个缓存工作？ 小白: 哇塞，我老妈简直太棒了，您这解释简直太棒了，我要为您打 call。虽然您现在知道为什么电脑中为什么会有各种存储设备了，但我们还需要用一张图来对这些存储设备做个简单的总结。轻松一刻，请看图： 存储设备比较在图中我们可以看到存储容量越大的，读取数据的速度越慢，同时价格也越便宜。还有一点我没有告诉您，在图中只有硬盘在断电后，保存在硬盘中的数据依然会存在，寄存器、西皮柚缓存和内存断电后数据就会丢失。现在关于存储设备就先聊到这。 老妈: 既然你说完了存储设备，那西皮柚中的控制器和运算器是干什么的呢？ 小白: 控制器，顾名思义它是起控制作用的。控制器负责将西皮柚缓存中的数据读入到寄存器，同时它还负责控制各种输出、输入设备。比如我现在在用键盘打字，同时我能在显示器上看见我敲打出来的字，这些操作都是由控制器在背后完成。 在寄存器中存储有指令和数据，运算器 会根据寄存器中的指令对相应的数据进行运算。 老妈: 控制器我还能勉强理解，但这运算器、指令和数据令我头痛。 小白: 头痛就对了，因为我正要准备给您讲电脑是如何工作的，其实也就是西皮柚是如何工作的。 老妈: 真棒！ 小白: 您想知道电脑的硬盘里到底存的是什么吗？ 老妈: 那当然啊！ 小白: 我们可以把存储在硬盘的数据可以分为软件和可被软件操作的数据。 老妈: 你这里说的软件是什么？ 小白: 软件就是我每次播放视频、播放音乐和朋友聊天的那些工具。 老妈: 那些叫做软件的家伙为什么能播放视频呢？ 小白: 您还记得我会教电脑做事吗？ 老妈: 当然记得。 小白: 我们做每一件事都是有方法的，我将这些方法包装起来放在电脑中，然后经过一系列的复杂操作，被包裹起来的方法最终就成了软件。 老妈: 那可供软件操作的数据是什么呢？ 小白: 比如我现在要用电脑看视频和图片，这些图片和视频就是可供软件操作的数据。 老妈: 我想我已经理解了软件和可供软件操作的数据，但不知道我理解的对不对。 小白: 真厉害，您先别管对不对，只管把您的想法大胆地说出来。 老妈: 好的！我感觉软件和做红烧肉很像，我做红烧肉的过程和技巧就相当于一个软件，同时五花肉、糖和酱油等原材料就是被软件操作的数据。 小白: 我想吃颗炫迈，不停地为您打 call。 老妈: 低调，低调！ 小白: 哈哈！言归正传，既然我们已经知道软件是啥玩意儿了，那我们现在就要解释指令了。我们刚刚把软件解释成了做一件事的方法，现在我们要换一种说法了，软件是一组指令的集合。 老妈: 儿子，你这葫芦里又是卖的啥药？ 小白: 不急，我们继续拿红烧肉说事。我们先来通过一个流程图看看我们是如何烹制一道美味的红烧肉的。 红烧肉制作路程如图中所示，购买五花肉就是一个购买指令；判断红烧肉是否已经熟的动作就是一个判断指令；如果红烧肉已经熟了，就将其装盘，这就涉及到一个跳转的动作，也就是跳转指令。现在我们可以总结下西皮柚到底是如何做事的了：西皮柚通过寄存器、西皮柚缓存和内存硬盘中获取指令和数据，然后通过运算器使用指令对相应的数据进行运算。 老妈: 聊了半天，我总算是明白了你们程序员的工作了。你们程序员就是将生活中需要大量人力做的事情抽象出来，做成一个个的程序，然后我们给这些程序数据，最后得到我们想要的结果。 小白: 是这么回事。您还有什么问题吗？ 老妈: 我发现你在用电脑看视频的时候，同时还能和朋友们聊天，这是怎么回事？ 小白: 老妈您这观察的也忒仔细了。其实，电脑能同时做多件事，多亏了强大的西皮柚。 老妈: 西皮柚能够同时处理多件事吗？ 小白: 其实一个西皮柚在一个时间点也只能做一件事，只是它执行的速度非常快，快到它一会儿执行播放视频的程序，一会执行聊天的程序，让人觉得它们是在同时运行的。 小白: 老妈，我们下次再聊，我得看书充电了，我得保证有足够的知识量来满足您的好奇心。嘻嘻。。。 老妈: 木问题，加油！ 总结断断续续地终于胡编乱造完了，感谢大家能花时间读我这么多废话！因为对计算机的底层原理理解还不够深入，同时文字功底也一般，若有问题，还望大家指出，谢谢大家！ 参考 《程序是怎么跑起来的》 【日】 矢泽久雄 《编码的奥秘》 Charles Petzold 刘欣老师的公众号《码农翻身》","tags":[{"name":"计算机组成原理","slug":"计算机组成原理","permalink":"http://yoursite.com/tags/计算机组成原理/"}]}]