[{"title":"工作后的第一次面试","date":"2018-03-29T15:01:18.000Z","path":"2018/03/29/工作后的第一次面试/","text":"今天是 2018 年 3 月 29 日，我参加了工作以来的第一次面试。我现在的公司是一家养老型的公司，领导和同事都非常的好。我父母都还在工作，我不能就开始养老。不管找工作的过程和结果如何，我都要努力去搏一把，我将在下周一正式递交我的辞呈。 前面是辞职的理由，那么现在总结一下今天的面试： 我的实力一般，技术面试官认为我资历比较浅，HR 小姐姐用比较委婉的方式拒绝了我。 不论是在工作中还是在生活中，都应该做一个真诚的人，这是我一直以来都在坚持的。HR 小姐姐说现在找 Java 工作的人非常多，而且有很多人造假简历，他们都被假简历伤透了。我既能理解 HR 们的感受，也能那些造假简历的求职者的感受。不论我的简历被多少家公司拒绝，也不管有很多少人因一份假简历获得了一份不错的工作，我会始终坚持我的做法。我参加校园招聘的时候，我就是大部分求职者中的一股清流，因为在笔试环节有太多求职者玩点小心思，其中不乏 985 和 211 的学生。我没有在笔试遇到问题的时候耍小心思，因为我觉得找工作和女朋友是同一个道理，双方都应该坦诚相待。人总该去坚持些什么，而不是随大流。 技术官问了我以下的问题： 过去一年的工作内容 讲一讲 Spring 因为我现在的工作内容是写公司的人力招募系统，所以面试官问了我：如何处理历年的简历，时间久了会堆积大量的垃圾简历，但又不能删除，因为同一个求职者在之后的某个时间又会投简历 如何配置 Tomcat，项目是如何部署的 最后我聊了下我对 Hibernate 的一点看法 虽然这次面试考察的内容非常简单，但这也体现了我自身实力的不足，我需要学习的东西还有很多。很感谢今天面试我的 HR 和 技术面试官。","tags":[{"name":"面试","slug":"面试","permalink":"http://yoursite.com/tags/面试/"}]},{"title":"","date":"2018-03-28T11:39:36.530Z","path":"2018/03/28/简历/","text":"个人信息 手机：17680328358 微信：cnboDev 邮箱：hubo17680328358@163.com 胡博/男/1995 本科/湖南工程学院/通信工程 工作年限：1 年 GitHub：https://github.com/cnbo Blog：http://chaoo.oschina.io/ 期望职位：Java 开发工程师 工作经历深圳富士康（2017.4 ~ 至今）富士康 C 次集团人力招募后台管理系统（2017.9 ~ 至今） 项目介绍：此系统用于公司人力招募，主要包含的功能有：公司各部门提交人力需求申请、主管在线签核申请单、简历筛选、笔试成绩确认、笔试题库管理和招聘路线发布。 项目用到的技术：Struts2 + Spring + Hibernate + HTML/CSS/Jquery + Oracle + Tomcat 本人主要负责的有：- 负责与人资进行沟通，设计 UE 和编写需求文档- 负责数据库表设计- 协调组员完成各自功能模块的开发和测试- 负责人力需求申请和主管签核模块的前后端开发 富士康 C 次集团绩效考核系统（2017.6 ~ 2017.9） 项目描述：用于公司员工绩效考核，功能有：员工绩效信息录入、员工自评、主管考核和考核成绩统计。 项目用的技术：Struts1 + Servlet + JSP + Oracle + Tomcat 本人主要负责的有：- 在绩效考核开始前对上一年留下的 Bug 进行修复- 在绩效考核期间维护系统的稳定运行- 在考核结束后修复系统事务乱用的问题。 作品 数字货币价格监控（https://github.com/cnbo/CoinMonitor/tree/dev/1.0） 技能清单 框架：Spring/SpringMVC/MyBatis/Hibernate/Struts2 数据库：Oracle/MySQL 前端：Html/CSS/Jquery/Ajax 工具：Git/Maven 单元测试：Junit","tags":[]},{"title":"小白的 Git 学习笔记","date":"2018-03-25T01:50:54.000Z","path":"2018/03/25/git-学习笔记/","text":"Git &amp; GitHub 简单介绍GitGit 是一个分布式的版本控制系统。网上有各种关于 Git 的介绍，我就不再照搬了，下面是我对 Git 的 理解: Git 能够帮助我们在计算机中构建一段理想化的人生，满足我们所有的幻想 Git 能够封存人生每一个阶段的记忆 在 Git 的世界，我们不再需要忘情水，因为过去可以被重写 人生不可以重来，但在 Git 的世界，我们可以在过去和现在来去自如 真实的人生只有一条路，在 Git 的世界我们就不用再说「如果当初怎样怎样，现在就会怎样怎样」的废话了 在生活中，我们更多的是一个人在追梦；有了 Git，我们可以一起筑梦 GitHubGitHub 是一个托管 Git 仓库「Repository」的网站。GitHub 给我们的学习和工作带来了很大的方便，下面是我所知道的 GitHub 的方便之处: 无需自己搭建远程主机用于保存 Repository。因为 GitHub 可以让我们建立免费的共有仓库，如果想建立私有 Repository，那就需要付费了。 我们可以使用 Git 方便地在多台设备上对同一个项目进行更新。因为我们在本地对项目所做的更新可以通过简单的 Git 命令推送到 GitHub。 我们可以在 GitHub 与他人合作开发和维护一个项目。因为 GitHub 提供了 fork、issue、wiki 和 pull request 等功能，给协同开发提供了极大的便利。 GitHub 上有大量优秀的开源项目。我可以不用重复造轮子，在 GitHub 上就能找到我们需要的项目。 GitHub 还有很多的神奇之处，随着使用的深入会逐渐发现。 一个美丽的误会很多时候，初学者会将 Git 和 GitHub 混为一谈。通过上述 Git 和 GitHub 地简单介绍，我们会发现他们俩并不是一回事。Git 是一个对 Repository 进行各种操作的工具，GitHub 一个提供远程保存 Repository 和学习交流的网站。这下就很清楚了，这个美丽误会的根本原因是 GitHub 是基于 Git 的。 别看 Git 和 GitHub 如此激情四射，其实是 GitHub 非 Git 不娶，Git 把 GitHub 当备胎。因为我们可以自建远程仓库，而且很多公司都是这样做的，还有就是我们可以使用开源中国的码云。 GitHub 是最大的开源社区，没事就去逛一逛，这要比刷微博好太多了。 Git 常用操作学习创建仓库创建仓库的方式有两种，确切地来说应该是在本地使用仓库的方式有种： 自建仓库 建立一个空文件，例如： 1mkdir first-git-project 进入刚刚建立的文件夹，然后初始化 Git 仓库，操作命令如下： 12cd first-git-projectgit init 接着输入下面的下命令来检查是否创建成功，如果成功会看见一个名为 .git 的文件夹，它就是我们的 Git 仓库了。 1ls 现在本地仓库算是建立好了，但现在只能在本地对仓库进行操作，而不能将本地仓库推送到远程。要想让本地仓库与远程仓库建立连接，那得在如 GitHub 这样的托管平台或者我们自己的远程服务器上再创建一个仓库。我们使用下面的命令将本地仓库与远程仓库关联起来。 12# git remote add &lt;给远程仓库起的别名&gt; &lt;远程仓库的地址&gt;git remote add origin git@github.com:cnbo/my-first-repository.git 在上面的命令中 remote 是远程的意思，origin 是我们给远程仓库起的一个别名，这样有了这个别名后，我们在就可以用 origin 代表远程仓库。至于给远程仓库起砂别名，我们可以随意，但普遍使用 origin。命令中跟随在 origin 后面的是远程仓库的地址。 经过上面的操作后，我们算是把本地仓库建立好了。 克隆远程仓库 克隆远程仓库到本地就非常容易了，准备好远程仓库的地址，然后输入下面的命令就好了。1git clone git@github.com:cnbo/my-first-repository.git first-git-project 上面命令的意思是：我们将 git@github.com:cnbo/my-first-repository.git 这个地址的仓库克隆到本地的名为 first-git-project 的文件下。我们也可以不指定文件名，那么系统会给我们建一个与仓库同名的文件夹，命令如下所示。 1git clone git@github.com:cnbo/my-first-repository.git 注意： 在上面的命令中， git remote 和 git clone 都是与远程仓库打交道，这时系统会要求我们输入远程仓库的账号和密码，在接下来的内容也一样，只要与远程有关的命令都会要求输入账号和密码。我们也可以在本地保存远程仓库的账号和密码，具体操作见文章底部的 Git 学习资源链接，里面会有详细的教程。 在 Windows 环境下我们使用 Git bash，在 Mac 和 Linux 环境下使用 Terminal。在 Git bash 和 Terminal 中使用的命令都是相同的。在对项目使用 Git 命令进行操作时，要定位到项目所在的文件夹。 提交和更新远程仓库创建好仓库后，我们不能就让它这么空着，那就让我们开始发挥它的价值。首先输入下面的命令在仓库所在的文件下创建一个 test.md 文件。1touch test.md 这个时候我们的仓库就不再空虚了，真的吗？我可以负责任的说：这时仓库依旧空虚寂寞冷，不信我们来输入下面的命令一探究竟。1git status 输入上面的命令后，我们将看到图 1 所示的效果。git status 命令的作用是查看仓库的状态。 图 1 我们在图 1 中发现 test.md 被标记成了红色，而且提示我们使用 git add 的命令，这样我们就可以 commit 了。如果不信，我们来是用下面这条命令试试看。1git push origin master 我们先来认识下这条命令，这条命令的意思是：将本地仓库的 master 分支推送到远程仓库的 master 分支。关于 master 分支是啥，我们稍后再去了解，origin 我们前面说过，它代表远程仓库。那么执行这条命令后会看到什么结果呢？请看图 2。 图 2 哈哈，结果很明显，我们的更新推送失败。我们还是老老实实地按照图 1 的提示使用 git add 命令。来吧！12git add test.mdgit status 执行上面的两条命令后，我们将看到图 3 所示的效果。 图 3 我们来解读下这条命令，git add 表示把指定的文件添加到 stage「暂存区」，被加入到暂存区的文件会被标记为绿色。咦，暂存区是个什么东东？我们输入下面的命令看看 .git 里都有些啥。1234#打开 .gitcd .git#列出 .git 下的内容ls 下面图 4 所示的就是 .git 中的内容了，内容很丰富，我们现在只需要知道 index 就是我们所说的暂存区了。不要问我为什么，我们所说的 stage 就是 .git 中的 index，具体为啥我也一脸囊然。 图 4 我们现在往 test.md 写如下几行数据试试看。1当帅气的程序猿遇上美丽的程序媛，会发生什么故事呢？ 好了，我们现在输入 git status 查看下效果，如图 5 所示。 图 5 我们发现在图 5 中出现了一个奇怪的现象：git 提示我们被绿色标记的 test.md 可以被 commit(changes to be committed) 了；同时 git 又提示我们被红色标记的 test.md 还没有被添加到暂存区(changes not staged for commit)。这就有意思了，我们明明只创建了一个 test.md，刚刚只是在 test.md 加了点文字，就似乎出现了两个文件。难道真是出现了两个同名的文件，我们可以执行 ls 命令查看是否真的有两个同名的文件。我就不截图了，执行 ls 后，我们发现确实只有一个 test.md。要想知道为什么，那就继续执行下面的命令。1git diff -p --status 分支的相关操作解决冲突修改历史提交保护现场工作流——Feature BranchingGit 常用命令速查表 常用命令 作用 git init 初始化仓库 git status 查看 git 仓库状态 git add 将文件加入到 stage「暂存区」 git rm –cached 将文件从 stage 区移除 git commit -m ‘输入提交信息’ 将 stage 区域的文件提交，并加上对应的提交信息 git log 查看提交日志 git branch 查看当前 branch 的状态，如果仓库是新建的，而且还没有做过任何 commit，那么输入此命令将没任何效果 git branch &lt; branch name &gt; 创建 branch，如果仓库还没有 commit 记录，那么此命令是无效的，输入此命令会提示 master branch 无效 git checkout &lt; branch name &gt; 切换到指定分支 git checkout -b &lt; branch name &gt; 创建并切换到新建的 branch git checkout &lt; tag name &gt; 切换到指定 tag git checkout &lt; commit id &gt; 切换到指定 commit git merge &lt; branch name &gt; 将指定 branch 合并到当前 branch git branch -d &lt; branch name &gt; 删除指定 branch，如果该 branch 没有被 merge，那么无法删除 git branch -D &lt; branch name &gt; 强行删除没有进行 merge 的 branch git tag 查看历史标签 git push origin master 将本地 master branch 推送到远程仓库 origin 的 master branch git pull origin master 将远程 master branch 更新到本地 master branch git clone &lt; 远程仓库的 SSH 地址 &gt; &lt; 指定 clone 到本地后的文件夹名称 &gt; 将远程仓库克隆到本地，可以选择重新命名克隆的仓库 git remote add origin &lt; 远程仓库的 SSH 地址 &gt; 这条命令是在本地使用 git init 命令初始化仓库后使用的，目的是将本地仓库与远程仓库关联起来，orgin 是远程仓库的名字，可以随便起 git remote -v 查看当前项目与哪些远程仓库进行了关联 git config –global alias.ci commit 使用 alias 给命令起别名，此条命令的意思是我们以后可以使用 git ci 代替 git commit；这只是一个示例，我们还可以给其他的命令起别名 git log –graph –pretty=format:’%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset’ –abbrev-commit –date=relative 输入此命令后，我们将会看到美化后的日志 git diff 输入此命令可以看到文件在被加入到 stage 区域后被做了哪些修改 git stash git stash list git stash apply git stash drop git stash pop git stash clear git merge git rebase git branch 查看本地分支列表 git branch -r 查看远程分支列表 git push origin :&lt; branch name &gt; 删除远程分支 git chechout &lt; branch name &gt; origin/&lt; branch name &gt; 把远程有，而本地没有的分支迁移到本地 git chechout -b &lt; branch name &gt; origin/&lt; branch name &gt; 迁移分支的同时并切换到该分支 Git &amp; GitHub 学习资源 链接 简要说明 free-programming-book 这个 GitHub 项目收录了大量免费的编程书籍，其中有一部分是 Git &amp; GitHub 学习相关的 Git 原理详解及使用指南 这是扔物线老师编写的掘金小册(付费，但很实用) 从 0 开始学习 GitHub 这是 stormzhang 编写的 Git 和 GitHub 入门教程，简单实用","tags":[{"name":"Git","slug":"Git","permalink":"http://yoursite.com/tags/Git/"}]},{"title":"小白和老妈聊计算机组成原理","date":"2018-03-24T07:54:20.000Z","path":"2018/03/24/小白和老妈聊计算机组成原理/","text":"前言 这段时间看完了 《编码的奥秘》和 《程序是怎样跑起来的》这两本书，我想尝试用大白话聊聊计算机组成原理。在 《程序是怎样跑起来的》 这本书中，有几个故事片段：向小学生讲解 CPU 和二进制、向沉迷游戏的中学生讲解内存和磁盘、向喜欢玩手机的女高中生讲解操作系统的作用、向邻居老太太说明显示器和电视机的不同。我觉得作者的想法太棒了，将晦涩难懂的计算机知识以通俗的方式讲解给不太了解计算机知识的人，这样不仅有利于我们自己对计算机的理解，同时也能让更多的人了解计算机知识。 在个人计算机和智能手机泛滥的现在，依然有很多人不了解计算机，即使他们每天都在使用他们。像我这样计算机专业的学生要不是恶补计算机组成原理，可能对计算机也是个模糊的概念。然后就是有很多人并不清楚程序员的工作到底是什么，尤其是我们的上一辈。受到 《程序是怎样跑起来的》 一书的启发，我将模拟和老妈的对话来聊计算机组成原理。我老妈没有接受过多少教育，我将会用生活中的一些普通事务来给她讲解计算机。计算机的出现是为了解决生活中的问题，让机器去做本该人去做的事，那么，用生活中的事务来类比计算机的组成和运行原理应该是行得通的。 小白是我一同学以牙还牙给我的外号，我觉得这外号太赞了，因为我在技术上是个小白。 小白和老妈的聊天记录 老妈: 儿子，你能给老妈讲讲你的工作具体是干什么的吗？ 小白: 妈，您也这太难为我了吧，即使给您了说了，您也不懂啊！ 老妈: 儿子，你不说，怎么就知道我不懂呢？如果你不能将自己所学的知识讲给别人听，你又怎么知道自己是否真正理解了学习过的知识。 小白: 还是老妈您厉害，说的太有道理了。容我先想想如何给您介绍我的工作。 旁白: 老妈不仅不会计算机，也没上过几年学，要向她介绍程序员的工作和计算机，这任务难度可不小啊。但是再难，也得想办法让老妈听懂，毕竟我出生的时候既不会说话，也不会走路，因为老妈的细心教导，我才学会了说话、走路。 思考中…… 小白: 老妈，我的工作是和计算机打交道，您知道您每天都在使用计算机吗？ 老妈: 不对啊，你在学校学的不是电脑吗，怎么是和计算器打交道呢？ 小白: 哈哈，您真幽默！我来慢慢给您解释。我们平常生活中所说的计算机，一般是指计算器，用来在购买商品时计算价钱用的。而我现在说的计算机不是用来做简单算术的计算器，我所说的计算机就是您给我买的电脑。严格来说，您给我买的电脑叫做个人计算机，是计算机的一种。电脑是我工作的工具。 计算器计算机 老妈: 你这信息量有点大，你老妈我有点懵。你能讲讲那计算器，哦，不对，就是你那计算机到底是个什么玩意，你又是如何用它来工作的，你的工作内容又是什么？ 小白: 老妈，您先别急，容我给您细细道来。为了不让您犯糊涂，接下来我会将计算机说成电脑。您是否记得，家里每次卖棉花的时候，老爸都会将每一包棉花的重量记录在本子上，最后一通加减乘除计算出棉花值多少钱，与老爸一起计算价钱的还有收棉花的商人，不过商人使用的是计算器。老爸需要知道加减乘除是怎么回事，他才能计算出最终的结果，而商人只需要将数据输入到计算器中，然后计算器就会告诉商人正确的结果。在这个过程中，商人并不需要自己会加减乘除，他只需要学会使用计算器就好了。通过这个故事您是否发现，计算器做了一部分本应该是人该做的事，而我们只要把数据给计算器，计算器就会返回一个结果给人，我们并不需要关心计算器是如何做到的。您是不是觉得计算器很聪明呢？ 老妈: 按你这么说，计算器确实很聪明。但是，儿子，你想通过这个故事说明什么呢？ 小白: 其实计算器本来并不知道如何进行加减乘除操作的，是我们告诉计算器如何进行加减乘除的。我想您现在应该对我的工作有点模糊的概念了，我的工作就是告诉计算器和电脑这些机器如何帮助我们人类做事。 老妈: 那你又是如何教它们做事的呢？ 小白: 这是个好问题，告诉您一个秘密，我会和电脑说话，哈哈。。。 老妈: 你这臭小子，净瞎扯，那你和电脑说个话给我看看。 小白: 我没瞎扯，我确实会和电脑说话，只是不能像我和您这样人类的语言非常流畅地聊天。电脑要听懂我的话要经历一个非常复杂的过程。要想把这个复杂的过程说清楚，可能会很难，您还想继续听我瞎扯下去吗？ 老妈: 你少废话，这好不容易听到有意思的地方了，你就想吊我胃口然后跑路，想得美，继续你的表演。 小白: 好的，小的遵命。我想告诉您，电脑和我们人一样，它们也有自己的语言。 老妈: 哇，这么神奇！那它们的语言是什么呢？ 小白: 它们的语言就是 0 和 1，您如果要和它们聊天，那么就是您吧啦吧啦地说一连串的 0 和 1，然后它们也用一连串的 0 和 1 回应您。估计您现在又在犯愁了。 老妈: 确实犯愁，那它们是如何用 0 和 1 来传达信息的？ 小白: 不愧是我亲妈，问的问题越来越有深度了。您可不要小看这简单的 0 和 1，它们可是很强大的。我们先从硬币说起，一枚硬币有两面，一面是有花的，一面是有字的。那么电脑是如何形容硬币的两面的呢？您要记住，电脑只会说 0 和 1。 老妈: 我是这么想的，也不知道对不对，电脑应该是用 0 表示硬币带花的一面，用 1 表示带字的一面。 小白: 此处应有掌声，老妈简直太棒了。那我们现在来一个稍微复杂点的，您不是经常找好友们打打麻将吗，你们需要用骰子来确定从哪里开始起牌。那我们现在就要用这骰子来搞事情。骰子有六面，它们分别表示 1、2、3、4、5、6 这六个数字，现在让我们来想想电脑是如何用 0 和 1 来表示这六个数的呢？ 老妈: 这我就猜不到了。 小白: 没事，让我来为您揭开谜底，咱们先看下面这张表格。 电脑是如何表示骰子的六个面的是不是很神奇，电脑竟然能用 0 和 1 的组合来表示骰子的六个面。老妈: 难道电脑只能用 0 和 1 来表示 6 以内的这些简单数字吗？小白: 当然不只这些简单的数字啦，如果想要表示更大的数字，就需要更长的 0 和 1 的组合。我们现在没有必要去深究如何用 0 和 1 表示更复杂的数字，因为这已经超出了您所能承受的范围，您只要知道电脑能用 0 和 1 来表示我们生活中的数字就行了。老妈: 难道电脑就只能用 0 和 1 表示数字吗？小白: 那肯定不是啦，让我再来为您举个例子。用 0 和 1 给小朋友起名字您看，上图的表格张有四个小朋友的名字，现在我用 0 和 1 给他们分别起了一个新名字，让电脑能够认识这些可爱的小家伙们。通过这三个例子，我们可以发现，我们可以用 0 和 1 表达任何信息。关于 0 和 1 的故事还有更加复杂的，我们就不再追究了，重要的是我们知道 0 和 1 是电脑的语言。『注: 如果大家想了解更多 0 和 1 的故事，可以细细品尝 《编码的奥秘》这本书。』老妈: 儿子，你能讲讲为什么电脑的语言是 0 和 1 吗？小白: 妈，咱先来个抱抱，您的问题越来越有深度了，我当然乐意给您讲讲为什么了。您知道为什么电脑叫电脑吗？老妈: 不知道。。。小白: 因为电脑确实有一个大脑，让我们先看看它长啥样。![计算机的大脑——西皮柚 (CPU)]计算机的大脑——西皮柚(CPU) 老妈: 这就是电脑的大脑了呢？可别糊弄我哦。 小白: 哪敢糊弄您啊，这确实就是电脑的大脑了。您可别看它长得如此秀气，它的内部结构复杂到您无法想象，而且功能非常强大。 老妈: 那怎么称呼它呢？ 小白: 它叫西皮柚 ( CPU——Central Processing Unit)，是不是听着像是某种柚子的名字。 老妈: 这名字有点意思。你这说了老半天，似乎还没进入正题啊。 小白: 别急嘛，咱得一个萝卜一个坑，循序渐进地深入。您别听我说它内部非常的复杂，就觉得它深不可测了，再高的大楼都是由一块块的砖头堆积起来的，其实西皮柚的内部是由无数个开关(晶体管)组成的。 老妈: 由开关组成的？ 小白: 是的，就是由开关组成的。您完全可以把它理解成我们家里点灯的开关，现在是不是觉得很神奇呢？ 老妈: 确实很神奇，太意外了。 小白: 我们现在已经接触到真相了。我们在使用开关控制灯的时候，永远只有两种状态，要么是关灯，要么是开灯，觉不会有第三种情况。 老妈: 这不就和硬币的正反面是一个道理么。 小白: 是的。之所以电脑的语言是 0 和 1，就是因为西皮柚是由开关组成的，一个开关永远只有两种状态，我们可以用 0 和 1 来表示开关的状态。虽然一个开关只有两种状态，但很多个开关连接起来就可以有很多状态了，也就是可以组成很多 0 和 1 了，也就意味着可以表示很多复杂的信息了。 老妈: 既然我们现在知道电脑的语言是 0 和 1 了，那你是如何与它交流的呢？ 小白: 因为我和电脑之间用的是两种不同的语言，所以这个交流的过程非常曲折。让我们先来看看生活中的电脑是由那几部分组成的。 笔记本 台式电脑上面两张图是我们生活中所能接触到的电脑，左图我们称之为笔记本，右图我们称之为台式电脑，从图中我们可以看出，它们都有一个键盘、一个鼠标和一个显示器。 老妈: 右图中不是还有一个大黑箱子吗，那个黑箱子是什么东西，为什么笔记本没有呢？ 小白： 那个大黑箱子才是真正的宝贝啊，值钱的东西可都在里面啊，西皮柚可就藏在那里面，那些什么键盘啊，鼠标都是些配角。其实笔记本也有那黑箱子，只是它体积变小了，而且位置稍微有点不起眼，笔记本的黑箱子就在键盘的底下。 老妈: 既然显示器和键盘是配角，那他们的作用是什么呢？ 小白: 键盘是一个输入设备，我们通过键盘将我的话和数据告诉电脑；显示器是一个输出设备，我们可以通过显示器看到电脑给我们反馈的结果。输入和输出设备还有很多，比如话筒 (输入设备)、音响 (输出设备)等等。我们接着来看一下我和电脑交流的简要过程图。 小白和电脑交流的过程通过上面的图，我们可以发现，其实我和电脑交流，本质上是和它的西皮柚交流。 老妈: 怎么图中还有一个翻译官？ 小白: 翻译官可是我大爷啊，要是没它，我和电脑就只能大眼瞪小眼了。我说的是为计算机定做的英语，也就是我常说的编程语言，电脑说的是 0 和 1，这压根没法交流。 老妈: 那你就不能去学习用 0 和 1 说话么？ 小白: 您也知道，您儿子没啥别的特点，就是懒。电脑那 0 和 1 的语言太难了，对于我来说和天书没差别。我们这世界很有意思的一个地方就是：除了有像我这种非常懒得人，也有非常勤劳和充满智慧的人。有一群被我试做为神的人，他们不仅精通编程语言，还精通电脑的0 和 1，他们可以用 0 和 1 愉快地和电脑聊天。因为那些人毕竟是少数，所以他们为了方便跟多的人于电脑进行交流，他们就制作了一个翻译官，将其放置在电脑的内部，这个翻译官能够将编程语言翻译为电脑能够理解的 0 和 1。 老妈: 你这臭小子，多花点时间跟那些大牛们学学，别每天只知道吃喝玩乐。那我看见你每次用电脑和同学聊天或者是看电影，也没输入什么编程语言啊。 小白: 您这各个问题都能命中要害，真棒！老妈，我在工作中是教电脑如何做事，而在生活中我是使唤电脑做事。如果我每次使唤电脑做事的时候，我还要去教电脑如何做事，估计会有好多人会和我上街去乞讨，有些人会砸了电脑然后去做些不理智的事。 老妈: 按你这么说，电脑它能记住你教它做的事吗？ 小白: 那必须的啊，不然为啥它叫电脑呢，记忆功能那是必须有的。 老妈: 你是说那个什么西皮柚还有记忆功能？ 小白: 关于记忆这事，那可不敢劳烦它老人家，它是只要没电了，就会停止工作，然后忘掉所有的事情。 老妈: 你这小子，葫芦里还有啥宝贝，别藏着掖着了。 小白: 无图无真相，我们来看看电脑的那个黑箱子除了西皮柚子还有些啥玩意儿。 电脑的关键组成部分老妈: 这图里面都是些啥东西啊？ 小白: 我之前不是说电脑能记住我教它做的事么，电脑很聪明，它把学会的事情都记忆在那个叫做硬盘的设备中了。当我告诉电脑我要听歌时，电脑就从硬盘那找播放音乐的技能。在硬盘中不仅可以存储电脑学会的各种厉害的技能，还可以存储我收藏的视频、音乐、图片和书籍等等，它可以存储很多东西。说白了，硬盘就是电脑中的一个仓库。 老妈: 既然硬盘是仓库，那图中其它几个东东又是干什么的呢？ 小白: 其实内存、西皮柚缓存和寄存器也是用来存储东西的。 老妈: 为什么需要这么多存储设备呢？它们之间有什么差别吗？ 小白: 因为西皮柚在做一件事情的时候，它不能直接从硬盘那个家伙那里直接获取数据。 老妈: 为什么呢？ 小白: 想要知道为什么，您先得回答我几个问题。 老妈: 好，继续你的表演。 小白: 您平时买东西是用什么付款？ 老妈: 晕，当然是钱啊！ 小白: 我的意思是，您出门在外，钱是放在哪里的。 老妈: 钱包啊。 小白: 您每天出门前似乎都会检查下钱包是否弹药充足，对吧。那您是如何保证每天出门时钱包都是元气满满的呢？ 老妈: 家里有保险柜啊，没钱了就从那拿就行了。 小白: 原来家里还有保险柜啊，那密码是多少？ 老妈: 你这臭小子绕来绕去，就是为了打听这事啊，没门儿！ 小白: 您老放心，我老板每个月都会按时给我发生活费，压根不会对您的小金库有什么非分之想。 老妈: 那就好，继续说正事。 小白: 那如果家里的保险柜快断粮了呢？ 老妈: 那当然是赶快去离得最近的取款机取钱啊。 小白: 那取款机没钱了怎么办？ 老妈: 那必须马上告知银行，让他们从金库运点钱过来让取款机吃饱喝足。你这问了半天，想表达什么呢？ 小白: 其实就在咱俩这一唱一和的过程中，我已经给您大概解释了下硬盘、内存、西皮柚缓存和寄存器它们之间的关系。 老妈: 有吗？ 小白: 必须的啊。我们先来看个表格。!内存设备和存钱设备的对应关系老妈: 我没看懂你这表格表达的意思。 小白: 您购物需要钱，这钱来自于您的钱包，而您钱包中的钱来自于家里的保险柜，保险柜中的钱来自于取款机，取款机中的钱来于银行的金库。电脑给我播放视频也是同样的道理，首先西皮柚会从寄存器获取相关的数据，而寄存器中的数据来自于西皮柚缓存，西皮柚缓存中的数据来自于内存，内存中的数据来自硬盘。 老妈: 我还是没想明白为什么需要这么复杂的过程。 小白: 之所以会有这么多中间过程，都是因为有个时间效率在从中作梗。老妈: 怎么说。 小白: 您为什么在购物的时候，不是直接从银行的金库取钱来付款？ 老妈: 要是我买个东西，还得先走个几天几夜去银行金库取钱，那还得了。嗯，我似乎明白了点什么。 小白: 其实我说了半天，就是想说，硬盘虽然能装很多东西，但别人从那取数据非常的耗时，而西皮柚做事又麻利，效率非常之高，您要是让西皮柚直接从硬盘那取数据的话，那西皮柚半天都做不完一件事。所以，要想充分利用西皮柚做事的效率，我们就为西皮柚准备了寄存器，寄存器存取数据的速度非常之快，深受西皮柚的喜爱，所以西皮柚是直接从寄存器获取数据。但是了，人无完人，金无足赤，寄存器虽然读取数据的速度很快，但它是以牺牲存储容量为代价的。所以，我们又为寄存器准备了西皮柚缓存，西皮柚缓存读取数据的速度要比寄存器慢点，但它的存储容量要比寄存器大。毕竟西皮柚缓存的容量也是有限的，还是不能满足需求，那么我们又在西皮柚缓存和硬盘之间加了一个内存，内存的读取速度和存储容量刚好介于西皮柚缓存和硬盘之间。 老妈: 儿子，你说了这么一大堆，是不是想表达为了匹配西皮柚的工作效率，需要对西皮柚的数据做一个缓存工作？ 小白: 哇塞，我老妈简直太棒了，您这解释简直太棒了，我要为您打 call。虽然您现在知道为什么电脑中为什么会有各种存储设备了，但我们还需要用一张图来对这些存储设备做个简单的总结。轻松一刻，请看图： 存储设备比较在图中我们可以看到存储容量越大的，读取数据的速度越慢，同时价格也越便宜。还有一点我没有告诉您，在图中只有硬盘在断电后，保存在硬盘中的数据依然会存在，寄存器、西皮柚缓存和内存断电后数据就会丢失。现在关于存储设备就先聊到这。 老妈: 既然你说完了存储设备，那西皮柚中的控制器和运算器是干什么的呢？ 小白: 控制器，顾名思义它是起控制作用的。控制器负责将西皮柚缓存中的数据读入到寄存器，同时它还负责控制各种输出、输入设备。比如我现在在用键盘打字，同时我能在显示器上看见我敲打出来的字，这些操作都是由控制器在背后完成。 在寄存器中存储有指令和数据，运算器 会根据寄存器中的指令对相应的数据进行运算。 老妈: 控制器我还能勉强理解，但这运算器、指令和数据令我头痛。 小白: 头痛就对了，因为我正要准备给您讲电脑是如何工作的，其实也就是西皮柚是如何工作的。 老妈: 真棒！ 小白: 您想知道电脑的硬盘里到底存的是什么吗？ 老妈: 那当然啊！ 小白: 我们可以把存储在硬盘的数据可以分为软件和可被软件操作的数据。 老妈: 你这里说的软件是什么？ 小白: 软件就是我每次播放视频、播放音乐和朋友聊天的那些工具。 老妈: 那些叫做软件的家伙为什么能播放视频呢？ 小白: 您还记得我会教电脑做事吗？ 老妈: 当然记得。 小白: 我们做每一件事都是有方法的，我将这些方法包装起来放在电脑中，然后经过一系列的复杂操作，被包裹起来的方法最终就成了软件。 老妈: 那可供软件操作的数据是什么呢？ 小白: 比如我现在要用电脑看视频和图片，这些图片和视频就是可供软件操作的数据。 老妈: 我想我已经理解了软件和可供软件操作的数据，但不知道我理解的对不对。 小白: 真厉害，您先别管对不对，只管把您的想法大胆地说出来。 老妈: 好的！我感觉软件和做红烧肉很像，我做红烧肉的过程和技巧就相当于一个软件，同时五花肉、糖和酱油等原材料就是被软件操作的数据。 小白: 我想吃颗炫迈，不停地为您打 call。 老妈: 低调，低调！ 小白: 哈哈！言归正传，既然我们已经知道软件是啥玩意儿了，那我们现在就要解释指令了。我们刚刚把软件解释成了做一件事的方法，现在我们要换一种说法了，软件是一组指令的集合。 老妈: 儿子，你这葫芦里又是卖的啥药？ 小白: 不急，我们继续拿红烧肉说事。我们先来通过一个流程图看看我们是如何烹制一道美味的红烧肉的。 红烧肉制作路程如图中所示，购买五花肉就是一个购买指令；判断红烧肉是否已经熟的动作就是一个判断指令；如果红烧肉已经熟了，就将其装盘，这就涉及到一个跳转的动作，也就是跳转指令。现在我们可以总结下西皮柚到底是如何做事的了：西皮柚通过寄存器、西皮柚缓存和内存硬盘中获取指令和数据，然后通过运算器使用指令对相应的数据进行运算。 老妈: 聊了半天，我总算是明白了你们程序员的工作了。你们程序员就是将生活中需要大量人力做的事情抽象出来，做成一个个的程序，然后我们给这些程序数据，最后得到我们想要的结果。 小白: 是这么回事。您还有什么问题吗？ 老妈: 我发现你在用电脑看视频的时候，同时还能和朋友们聊天，这是怎么回事？ 小白: 老妈您这观察的也忒仔细了。其实，电脑能同时做多件事，多亏了强大的西皮柚。 老妈: 西皮柚能够同时处理多件事吗？ 小白: 其实一个西皮柚在一个时间点也只能做一件事，只是它执行的速度非常快，快到它一会儿执行播放视频的程序，一会执行聊天的程序，让人觉得它们是在同时运行的。 小白: 老妈，我们下次再聊，我得看书充电了，我得保证有足够的知识量来满足您的好奇心。嘻嘻。。。 老妈: 木问题，加油！ 总结断断续续地终于胡编乱造完了，感谢大家能花时间读我这么多废话！因为对计算机的底层原理理解还不够深入，同时文字功底也一般，若有问题，还望大家指出，谢谢大家！ 参考 《程序是怎么跑起来的》 【日】 矢泽久雄 《编码的奥秘》 Charles Petzold 刘欣老师的公众号《码农翻身》","tags":[{"name":"计算机组成原理","slug":"计算机组成原理","permalink":"http://yoursite.com/tags/计算机组成原理/"}]},{"title":"学习 Java8 函数式编程 (四)","date":"2018-03-24T07:49:01.000Z","path":"2018/03/24/学习-Java8-函数式编程-四/","text":"扯淡按照之前的习惯，本文的开头依旧是扯淡。其实，做软件开发确实非常难，我们需要经常学习新的技术，我们还要有几门非常精通的技术。因为这些，我们需要花费大量的时间在工作和学习上。正好，坚持写技术博客能够提高我们学习的效率，同时有利于技术的沉淀和积累。把技术博客写好是件非常困难的事，这需要我们长时间的去坚持写技术博客和不断地充电思考。归根结缔，我们就是需要坚持。当我们坚持不下去的时候，去想想你是不是想给自己的家人更好的生活；你是不是希望看到自己心爱的那个她在看到它喜爱的口红时不再犹豫；你是不是想更加自信大胆地去追求一个位工作能力强于你的女生。我之所以还在坚持，是因为这三个问题一直在我脑中徘徊，还有我和哥们建立的约定。 上面说了那么多闲话，无非是对我们自己的一种激励。回到正题，在上一篇文博文中，我们用 Java8 提供的 Stream 解决了一个具体的问题。我们发现，使用 Stream 编程时，我们只需要写一段很短的代码，便能简洁明了的将代码的功能清晰地描述出来。有了 Stream 后，我们可以少写很多令人难懂的命令式代码，这样我们也可以少写很多注释，因为使用 Stream API 写出来的代码本身自带注释功能。今天我们要学习如何更好地使用 Stream。 灵活使用惰性求值和及早求值什么是惰性求值和及早求值我相信大家看到惰性求值和及早求值这两个概念时，完全不知道是怎么回事。不用担心，我们先来看看清单一和清单二中的代码。 清单一12345678910public class StreamAPILearn &#123; public static void main(String[] args) &#123; StreamAPILearn apiLearn = new StreamAPILearn(); apiLearn.fastGetValue(); &#125; public void fastGetValue() &#123; System.out.println(\"及早求值\"); &#125;&#125; 清单二12345678910public class StreamAPILearn &#123; public static void main(String[] args) &#123; Arrays.asList(2, 3, 4, 1, 5, 3, 7) .stream() .filter(x -&gt; &#123; System.out.println(\"惰性求值\"); return x &gt; 2; &#125;); &#125;&#125; 当大家执行完清单一中的代码后，会看见控制台打印出了及早求值。我在清单二的代码中也写了一条控制台打印语句，但执行完代码后，发现控制台什么也没有。其实清单一中的代码模拟了及早求值，清单二中的代码模拟了惰性求值。清单二中的 filter 方法是一个惰性求值方法，只有当它的后面调用了一个及早求值的方法，那条打印句才会被执行。 其实，上面两段代码并不能清晰地诠释及早求值和惰性求值，它们只是稍微进行了一些演示，让大家对这两个概念有个模糊的认识。我说下我最初对他们的认识，当我通过对象调用某个方法后嫩够得到一个结果，这就是及早求值；如果使用对象调用方法后，没有得到我想要的结果，这就是惰性求值，而这个惰性求值的方法只是用来描述一种行为，告诉对象我需要什么样的数据。 为什么会产生及早求值和惰性求值的概念我们还是先来看看中学习 Java8 函数式编程 (三) 实现「找出某张专辑中所有乐队的国籍」的两段代码，请见清单三和清单四。 清单三1234567891011121314//将专辑中的艺术家为乐队的单独放入一个集合 bankListList&lt;Artist&gt; artistList = album.getMusicians();List&lt;Artist&gt; bankList = new ArrayList&lt;&gt;();for (Artist artist : artistList) &#123; if (artist.getName().startsWith(\"The\")) &#123; bankList.add(artist); &#125;&#125;//找出 bankList 中每个乐队的国籍，并将国籍放入 originListList&lt;String&gt; originList = new ArrayList&lt;&gt;();for (Artist artist : bankList) &#123; originList.add(artist.getOrigin());&#125; 清单四12345Set&lt;String&gt; originList = album.getMusicians() .stream() .filter(artist -&gt; artist.getName().startsWith(\"The\")) .map(artist -&gt; artist.getOrigin()) .collect(toSet()); 清单三和清单四中的代码都是找到专辑中的所有乐队，然后再获取乐队的国籍。但不同的是，清单三中的代码使用了一个临时集合用来存储专辑中的所有乐队，而清单四中的代码并没有临时变量存储中间结果。 清单三中的代码，是断断续续地解决一个问题。在 Java8 之前我们都是按照清单三的风格写代码的，我们为了得到一个结果，在中途我们会使用很多临时变量存储中间结果，这些中间结果看似有助于让我们理解代码，实则不然，过多的中间结果反而会淡化我们真正想要的结果，让代码变得难懂。 清单四中的代码一气呵成地将问题解决，得到我们想要的结果。清单四中的代码结合使用了及早求值和惰性求值，在解决问题的过程中一直调用惰性求值方法 (filter 和 map) 告诉 Stream 需要对数据进行怎样的处理，当数据处理的操作全部完成后，再调用一个及早求值方法结束。 之所以会有及早求值和惰性求值，是因为程序员迫切希望，在一段处理某个问题的过程中，尽量少地出现一些多余的临时变量，增强代码的可读性，降低代码的冗余度。正好使用 Stream API 进行编程能满足我们的要求。 如何区分 Stream 中的及早求值和惰性求值方法在 Stream 中，有两种类型的方法，一种是有返回值的，另一种是无返回值的。有返回值的就是惰性求值方法，无返回值的就是及早求值方法。在以后大家使用 Stream API 编程的过程中，总会发现及早求值方法是最后调用的，而且只有一个，惰性求值方法会有多个，而且都在及早求值的方法之前调用。 总结关于 Stream 还有很多更深层次的知识，因为能力和经验有限，我还不能理解。在使用 Stream API 编程之前，一定要明白及早求值和惰性求值，再就是熟悉 Stream API，这样你们就知道在什么样的情况下该使用哪个方法。 彩蛋本篇博文的彩蛋，我给大家一位 Java 大神左潇龙，这是他的个人博客链接 http://www.zuoxiaolong.com/。 他目前就职于阿里巴巴的中间件团队，阿里巴巴的中间件团队在中国的 Java 领域是什么样的存在，请自行上网搜索。他和我们其中很多人一样，非名校毕业，也非计算机专业，他一步一个脚印取得他现有的成就。他的每篇博客都非常有营养，他还把自己的故事写成了小说。","tags":[{"name":"Java8","slug":"Java8","permalink":"http://yoursite.com/tags/Java8/"}]},{"title":"学习 Java8 函数式编程 (三)","date":"2018-03-24T07:42:29.000Z","path":"2018/03/24/学习-Java8-函数式编程-三/","text":"扯淡在准备学 Java8 之前，我以为不会很难。所以，我就决定一边学 Java8，一边写博客。当我准备写这篇博客的时候，我发现两件都不容易。如果不是我亲身体验，我也没法知道一篇博客的背后，作者得付出多少时间和精力。这会让我在读每一篇博客时，保持对作者的敬畏之心。 本篇博客会简单介绍 Stream，以及认识是用 Stream 的 API。当我不知道这篇博客该怎么写的时候，我想试着从 Stream 的源码去解读。然后，我就傻逼似的，屁颠屁颠地去看 Stream 源码，结果可想而知，我抱着头顶上的一堆星星去床上思考人生了。Stream 的功能非常强大，给我们这些普通的程序员带来了极大的方便。这必然意味着，Java 的布道师们会在底层实现一堆逻辑非常复杂的代码。所以，学习一门新技术的时候，我们应该先知道这门技术是什么，可以干什么，然后熟练掌握，最后深究它背后的实现原理。 认识 Stream第一眼看见 Stream 这个词的时候，会误认为和 Java 的 I/O 流有着不可描述的关系。其实，它们俩就像潘长江和曾志伟并不是兄弟一样，毫无关系。 其实和 Stream 有关系的是 Java 中的容器(我们经常使用的 List 和 Set 等集合)。在 Java8 之前，我们使用的是增强 for 语法糖和容器自身的 Iterator 来遍历数据。我们先来看下清单 1 中的代码，使用增强 for 和 Iterator 来遍历集合。 清单 112345678910111213List&lt;String&gt; strList = .asList(\"a\", \"b\", \"c\", \"d\");//使用增强 for 遍历集合for (String str : strList) &#123; System.out.println(str);&#125;//使用 Iterator 遍历集合Iterator iterator = strList.iterator();while (iterator.hasNext()) &#123; String str = iterator.next(); System.out.println(str);&#125; 清单 1 中的代码使用了增强 for 语法糖和 Iterator 来遍历一个集合。其实使用增强 for 和 Iterator 是一回事。因为增强 for 是 Java 为简化我们使用 Iterator 而提供的一个语法糖，它背后的实现依然是 Iterator。大家可能会发现，无论我们是使用增强 for 还是 Iteraotr 遍历集合，都需要将集合中的元素一个个的取出来。这种将元素从集合中取出来的迭代方式叫外部迭代。 现在，我们来看下清单 2 中的代码，使用 Java8 中的 Stream 来遍历集合。 清单 212List&lt;String&gt; strList = Arrays.asList(\"a\", \"b\", \"c\", \"d\");strList.stream() .forEach(str -&gt; System.out.println(str)); 当大家读完清单 2 中的代码后，是不是似乎有点知道 Stream 是干啥的了。通过请单 2 中的代码，我们只能看出 Stream 有遍历的集合功能，而且写法更加简单，代码的可读性也增强了。使用 Stream 遍历集合的方式叫内部迭代。 Java8 的布道师们利用了面向对象的思想，对容器的存储数据和遍历数据进行了解耦。从 Java8 开始，在绝大多数情况下，我们都会使用 Stream 来遍历集合，容器只用来存储数据，无需关心遍历。 按我的理解，Stream 就是一种新的迭代方式，它以一种更加简单的方式对数据进行处理，让代码简洁易懂。在接下来的内容中，大家会发现使用 Stream 处理数据的代码，我们能够清晰读出代码的意图，而且代码中没有多余的临时变量和命令式代码。同时，使用 Stream 操作数据，并不会改变数据源(可以是容器，可以是数组，也可以是其他类型的数据源)。在多核时代，我们可以使用 Stream 写出高效以及线程安全的代码。但这不意味着我们需要写线程相关的代码，因为 Stream 在底层已经帮我们实现了。 在接下来使用 Stream 的过程中，我们只需要在 Stream 的每个函数中传入一个函数，传入的函数只是用来告诉 Stream 需要做什么，具体该如何做，并不需要我们关心。 使用 Stream API准备三个类在使用 Stream API 之前，我们先准备三个类 Artist (创作音乐的个人或团队)，Track (专辑中的一些曲目)，Album (专辑，由若干曲目组成)。接下来的内容，都会围绕这三个类展开。这三个类的具体定义如清单 3, 4, 5 所示。 清单 312345678910111213public class Artist &#123; //艺术家的名字(例如 “纵贯线乐队”) private String name; //乐队成员(例如 “周华健\")，该字段可为空 private String members; //乐队来自哪里(例如 “台湾”) private String origin; //省略 set 和 get 方法&#125; 清单 4123456public class Track &#123; //曲目名称 private String name; //省略 set 和 get 方法&#125; 清单 512345678910111213public class Album &#123; //专辑名 private String name; //专辑上所有曲目的列表 private List&lt;Track&gt; tracks; //参与创作本专辑的艺术家列表 private List&lt;Artist&gt; musicians; //省略 set 和 get 方法&#125; 案例描述问题是，找出某张专辑上所有乐队的国籍。艺术家列表里既有个人，也有乐队，其中乐队名以 The 开头。 该问题可分解为如下几个步骤： 找出专辑上的所有表演者 分辨出哪些表演者是乐队 找出每个乐队的国籍 将找出的国籍放入一个集合 使用命令式代码实现我们先是使用命令式风格的代码实现上述案例，代码如清单 6 所示。 清单 61234567891011121314//将专辑中的艺术家为乐队的单独放入一个集合 bankListList&lt;Artist&gt; artistList = album.getMusicians();List&lt;Artist&gt; bankList = new ArrayList&lt;&gt;();for (Artist artist : artistList) &#123; if (artist.getName().startsWith(\"The\")) &#123; bankList.add(artist); &#125;&#125;//找出 bankList 中每个乐队的国籍，并将国籍放入 originListList&lt;String&gt; originList = new ArrayList&lt;&gt;();for (Artist artist : bankList) &#123; originList.add(artist.getOrigin());&#125; 清单 6 的代码存在如下问题： 存在多余的临时变量 样板式代码掩盖了关键代码，代码的可读性很低 使用 Stream API 实现我们现在使用 Stream API 来重写清单 6 中的代码，如清单 7 所示。 清单 712345Set&lt;String&gt; originList = album.getMusicians() .stream() .filter(artist -&gt; artist.getName().startsWith(\"The\")) .map(artist -&gt; artist.getOrigin()) .collect(toSet()); 当大家看到清单 7 的代码时候，有没有很惊喜？反正我是为之跳跃。我先来解读下这段代码。其实，当大家熟悉 Stream 的 API 后，一眼就能看出这段代码的意图，它简直就是将问题的每一个小步骤描述了一遍，没有一点拖泥带水。首先通过 getMusicians 获取 album (专辑) 中的艺术家列表；然后使用艺术家列表构建一个 Stream，这里要说的是，所有 Collection 的子类都可以使用 stream 方法来构建一个 Stream，因为 Java8 允许接口中有 default 方法；接着调用 Stream 的 filter 方法，并告诉它筛选出 Stream 中 艺术家名字以 The 开头的数据，将筛选出的数据组织成一个新的 Stream 返回；紧接着，调用 Stream 的 map 方法，将 Stream 中的艺术家映射为艺术家的国籍，返回新的 Stream；最后，使用 Stream 的 collect 方法生成一个 Set 集合。 经过清单6 中的代码与清单 7 中的代码进行比较，我想大家会一致认同，Stream 简直太好用了，写出来的代码简洁易懂。 结束语本篇博客只是简单介绍了 Stream 和 使用 Stream 解决问题的具体案例，在后续博客中，我会更加细致地介绍 Stream。 彩蛋我今天要给大家介绍的是，我的学长勇哥，这个是他在开源中国的地址 https://my.oschina.net/silence88。勇哥是个完美的 Java 程序员，人帅，会做菜，弹的一手好吉他(他就是因为吉他与我嫂子相识的)，会打篮球，最牛逼的还是写代码厉害。勇哥的博客值得一读，你们会看到一个屌丝程序员是如何打怪升级的。勇哥是在大四的第一个学期开始自学 Java 的，他现在顺丰的丰巢就职。 感谢大家的阅读～","tags":[{"name":"Java8","slug":"Java8","permalink":"http://yoursite.com/tags/Java8/"}]},{"title":"学习 Java8 函数式编程 (二)","date":"2018-03-24T07:31:13.000Z","path":"2018/03/24/学习-Java8-函数式编程-二/","text":"和 Lambda 表达式 Say Hello如果用一大段枯燥的文字去解释一个我们并不熟悉的概念，我觉得和看天书并无区别。我之所以选择学编程，就是因为没有什么是写段代码不能搞定的。那么废话少说，大家先看看清单一中的代码。 清单一1234567891011121314151617181920212223public class Calculater &#123; public static void main(String[] args) &#123; final int a = 1, b = 2; int result = add(new IIntegerMath() &#123; @Override public int operation() &#123; return a + b; &#125; &#125;); System.out.println(result); &#125; public static int add(IIntegerMath iIntegerMath) &#123; return iIntegerMath.operation(); &#125;&#125;interface IIntegerMath &#123; int operation();&#125; 看完清单一中的代码，估计有人要说我了，因为这段代码在上一篇博客中已经出现过了。但这又何妨，通过一段简单的代码，我们可以挖掘很多知识。在清单一代码的 main 函数中，我调用了 add 函数，并使用了一个匿名内部类作为 add 函数的参数。匿名内部类被设计的目的之一就是，方便程序员将代码作为数据传递。 现在问题来了，大家有没有觉得这样的代码太过于冗余了。我们明明只需要 a + b 这一条语句，却附加了很多其他的代码(命令式代码)。可能由于大家已经习惯了这样的写法，但 Java8 让我们可以用更加简单的代码实现相同的功能。那么，我们一起来看清单二中用 Java8 实现地与清单一功能相同的代码。 清单二123456789101112131415161718public class Calculater &#123; public static void main(String[] args) &#123; int a = 1, b = 2; int result = add(() -&gt; a + b); System.out.println(result); &#125; public static int add(IIntegerMath iIntegerMath) &#123; return iIntegerMath.operation(); &#125;&#125;interface IIntegerMath &#123; int operation();&#125; 如果有人认为清单二中的代码看着不爽，那么我建议他可以去泡个澡，然后剪个头发。其实清单二中的代码我已经在上篇博客中展示了，但我并没有解释 () -&gt; a + b 是几个意思。 我现在给大家分析下 () -&gt; a + b ，其实这段代码就是一个 Lambda 表达式，也可以理解为一个函数。-&gt; 将参数和 Lambda 表达式的主体分割开了，-&gt; 的左边是参数所在的位置，() 表示无参数；-&gt; 右边的代码是 Lambda 表达式的主体。 即使我们知道了 add 函数中那段代码是什么意思，我认为有些人对于在 add 函数中直接传入一个 Lambda 表达式还是难以理解。那么现在我用另一种方式重写清单二中 main 函数中的代码，请看清单三。 清单三1234567public static void main(String[] args) &#123; int a = 1, b = 2; IIntegerMath integerMath = () -&gt; a + b; int result = add(integerMath); System.out.println(result);&#125; 我相信清单三中的代码对于大家来说都很熟悉。当你无法理解使用 Lambda 表达式作为函数参数的用法，你们就将 Lambda 表达式理解为一个对象的引用，虽然按理来说我们不能这么来理解。 Lambda 表达式的多种形式不带参数的 Lambda 表达式清单四123456789public class LambdaLearn &#123; public static void main(String[] args) &#123; INoArguments noArguments = () -&gt; System.out.println(\"no argument\"); &#125;&#125;interface INoArguments &#123; void printOperation();&#125; 清单四中展示了一个不带参数的 Lambda 表达式，在 -&gt; 的左边使用空括号 () 代表没有参数。 带一个参数的 Lambda 表达式清单五123456789public class LambdaLearn &#123; public static void main(String[] args) &#123; IOneArguments&lt;Integer&gt; oneArguments = (a) -&gt; a &gt; 0; &#125;&#125;interface IOneArguments&lt;T&gt; &#123; boolean assertOneNum(T argument);&#125; 清单五展示了一个只带一个参数的 Lambda 表达式，因为只有一个参数，所以参数可以用括号包裹起来，也可以不用。 带多个参数的 Lambda 表达式清单六123456789public class LambdaLearn &#123; public static void main(String[] args) &#123; IMultiArguments&lt;Integer&gt; multiArguments = (a, b) -&gt; a + b; &#125;&#125;interface IMultiArguments&lt;T&gt; &#123; T addOperation(T a, T b);&#125; 清单六中展示了一个带多个参数的 Lambda 表达式。因为有多个参数，所以需要用括号将多个参数包裹起来。 注意：我不能用惯性思维去阅读清单六中 Lambda 表达式。该 Lambda 表达式并不是将两个数字相加，而是创建了一个函数，用来计算两个数字相加的结果。变量 multiIArguments 的类型是 IMultiArguments，它不是两个数字相加的和，而是将两个数字相加的那行代码。 主体用被{}包裹的 Lambda 表达式清单七1234567891011121314151617public class LambdaLearn &#123; public static void main(String[] args) &#123; INoArguments multiStatement = () -&gt; &#123; System.out.println(\"this is the first code\"); System.out.println(\"this is the second code\"); &#125;; INoArguments oneStatement = () -&gt; &#123; System.out.println(\"only one code\"); &#125;; &#125;&#125;interface INoArguments &#123; void printOperation();&#125; 清单七中展示了，如果 Lambda 表达式的主体有多行代码，那么就需要将多行代码用中括号 {} 包裹。其实当 Lambda 表达式的主体只有一行代码的时候，大家可以根据自己的习惯决定是否使用中括号。 通过 Lambda 表达式来看 Java8既成事实地final变量在我们学 Java 基础的时候，我们就知道匿名内部类只能引用外部的 final 变量。但我们却发现，被 Lambda 表达式引用的外部变量并没有被 final 修饰。如清单八中的代码所示，被 Lambda 表达式引用的外部变量 a 和 b 并诶有被 final 修饰，这是因为 Java8 为我们省去了一些操作，这样代码看上去会更加干净舒服。虽然 a 和 b 没有被显示地被 final 修饰，但它们依然是事实上的 final 变量。你们可以根据自己的喜好，选择性地给被 Lambda 表达式引用的外部变量加上 final 修饰符。 清单八1234567public static void main(String[] args) &#123; int a = 1, b = 2; IIntegerMath integerMath = () -&gt; a + b; int result = add(integerMath); System.out.println(result);&#125; 类型推断不知大家是否有注意，本文中使用的 Lambda 表达式都没有为参数指明类型，这是因为 Java8 引入了比 Java7 更加强大的目标类型推断。如清单九中的代码所示， Lambda 表达式的参数 x 并没有被指明类型，但 javac 会根据变量 atLeast 的类型 Predicate 推断出目标类型。在日常的开发中，请大家根据具体情况选择是否给 Lambda 表达式的参数显示地指明类型。 清单九12345Predicate&lt;Integer&gt; atLeast = x -&gt; x &gt; 5;interface Predicate&lt;Integer&gt; &#123; boolean test(T t);&#125; 彩蛋其实我的微信里有关注很多技术公众号，但真正喜欢并经常阅读的却寥寥无几，其中刘欣大神的码农翻身就是我非常喜欢的一个公众号。刘欣大哥是一个有 15 年工作经验的前 IBM 架构师，他是一个热爱编程的资深码农，他用心去写好每一篇博客，他的每篇博客都是一个故事，他用一个个精彩短小的故事解释有点枯燥的技术。下面是他公众号的二维码，请关注他，你们会收获很多。","tags":[{"name":"Java8","slug":"Java8","permalink":"http://yoursite.com/tags/Java8/"}]},{"title":"学习 Java8 函数式编程 (一)","date":"2018-03-24T07:26:11.000Z","path":"2018/03/24/学习-Java8-函数式编程-一/","text":"闲聊Java 一直以来是使用最广泛的编程语言之一，有很多人担心在为她的未来担心。但随着 Java8 的横空出世和即将发布的 Java9 让 Java 迎来了第二春。Java8 最大的改变是引入了函数式编程，Java9 引入了模块化编程。函数式和模块化编程 拥有非常美好的未来，很多优秀的编程语言如 JavaScript 和 Scala 都拥有这些特性。 我们为什么要学习 Java8 的函数式编程？ 为了编写出更加简单、干净、易读的代码。 为了简化集合的操作。 为了简单地使用并行计算提高程序的性能。 什么是函数式编程 函数式编程的核心是：在思考问题时，使用不可变值和函数，函数对一个值进行处理，映射成另一个值。面向对象编程是对数据进行抽象，而函数式编程是对行为进行抽象。 当看到上面的有点晦涩难懂的概念时，我相信大家和我一样都是一脸蒙逼。先别急，其实我们都有接触过函数式编程。可能你们会有疑问，不是 Java8 才引入函数式编程么，我们之前也没使用过 Java8 。为了消除大家的疑惑，我们先看看清单一中的代码。 清单一1234567891011121314151617181920212223public class Calculater &#123; public static void main(String[] args) &#123; final int a = 1, b = 2; int result = add(new IIntegerMath() &#123; @Override public int operation() &#123; return a + b; &#125; &#125;); System.out.println(result); &#125; public static int add(IIntegerMath iIntegerMath) &#123; return iIntegerMath.operation(); &#125;&#125;interface IIntegerMath &#123; int operation();&#125; 在清单一中我创建了一个类 Calculater 和一个接口 IIntegerMath 。在 Calculater 的 main 方法中，我调用了 Calculater 的静态方法 add 。在调用 add 方法时，我 new 了一个实现 IIntegerMath 接口的匿名内部类对象作为 add 方法的第参数。在匿名内部内中实现了具体的 operation 方法。 其实在给 add 方法传参数时，我们真正需要的是一个行为，也就是 IIntergerMath 接口中的 operaton 方法。这就是函数式编程要做的事，对行为进行抽象。「ps: 在这里我对函数式编程是对行为进行抽象这个概念解释的还不是很清楚，我相信你们通过具体的代码会有更加深刻清晰地理解。」 我相信大家有注意到， main 方法中的变量 a 和 b 被定义成了 final 类型的。因为如果在匿名内部类只能调用外部类的 final 变量。在 operation 方法中我们将 a 和 b 映射成了另一个值。在调用 add 方法时，我们在用函数式编程解决问题，我们在 add 方法中传入了一个方法(函数) operation ，而 operation 将不可变值 a 和 b 映射成了另一个值。 「ps： 我不知道我是否已将函数式编程的概念表达清楚了，如果大家有更好的见解，可以分享出来。」 初识 Lambda 表达式我相信大家已经发现，我用清单一中的代码解释什么是函数式编程显得非常牵强。因为清单一中的代码是 Java8 之前的写法，属于命令式代码。何为命令式代码？我是这么理解的，在写一段关键代码的同时要附加上很多样板式代码，这些样板式代码让真正有价值的部分黯然失色。在清单一中，你们会发现在调用 add 方法式，我们需要的仅仅是 operation 方法中的 return a + b，而其他的代码显得特别多余，这些多余的代码就属于样板式代码。 命令式风格的代码并不能让 Java 拥有函数式编程的特性。所以在 Java 8 引入了 Lambda 表达式。在本文中，我只会将清单一中的代码用 Lambda 表达式(见清单二)再重写一遍，将两种风格的代码呈现出来做一个对比，我会在之后的博客中详细介绍 Lambda 表达式。 清单二 123456789101112131415161718public class Calculater &#123; public static void main(String[] args) &#123; int a = 1, b = 2; int result = add(() -&gt; a + b); System.out.println(result); &#125; public static int add(IIntegerMath iIntegerMath) &#123; return iIntegerMath.operation(); &#125;&#125;interface IIntegerMath &#123; int operation();&#125; 大家看到清单二中的代码是不是有大吃一惊，我就用一行代码做了清单一中 n 多行代码才能完成的事。这就是 Lambda 表达式的神奇之处，清单二中的 Lambda 表达式 () -&gt; a + b 能够清晰地诠释函数式编程的核心思想。你们可能还是不理解我为什么要这么说，没事，我会在之后的博客中和大家一起深入地学习和探索 Lambda 表达式。 彩蛋我以后会坚持在每篇博客的末尾丢一个彩蛋，这个彩蛋可能是我认为非常好的书或者微信公号等等。 这次我要向大家推荐 stormzhang 。我从大三就开始关注他的公号，我一直在看他的文章。stormzhang 的文章种类很多，包括技术，理财，人生，职场等等。无论你是属于哪个行业，我相信 stormzhang 的文章都会对你有所益。 stormzhang 目前就职于上海薄荷信息科技有限公司，担任公司的技术主管。下图是他的公号的二维码。","tags":[{"name":"Java8","slug":"Java8","permalink":"http://yoursite.com/tags/Java8/"}]},{"title":"与开源有关的法律知识 【GitHub 开源贡献指南译文】","date":"2018-03-24T07:22:25.000Z","path":"2018/03/24/与开源有关的法律知识-【GitHub-开源贡献指南译文】/","text":"了解开源的法律含义向世界分享你们具有创造性的工作，这是一个多么令人激动和有价值的经历。这也意味着你们必须担心一堆你们不清楚的法律问题。幸运的是，你们不必从头开始。我们已经涵盖了你们的法律需求。（在你们行动前，请确定阅读了我们的免责声明。） 为什么大家非常担心有关开源的法律问题？很高兴你们提问！当你们行创造性工作（例如写作，图形或代码）时，默认情况下该作品属于专有版权（copyright）。也就是说，法律承认你们是你们作品的作者，他人在没有经得你们同意的情况下不能使用你们的工作。 一般来说，这意味着没有人可以在没有你们授权的情况下使用，复制，分发或者修改你们的工作。 然而，开源有着不一样的情况。因为作者希望他人使用，修改以及分享他们的工作。但因为法律默认依然是专有版权（copyright），所以你们需要一个明确说明这些权限的协议。 如果你们不应用开源许可协议，那么对你们项目做出贡献的人也都将成为其工作的专属版权（copyright）所有者。这意味着没有人（也包括你们）可以使用，复制，分发后者修改他们的贡献， 最后，你们的项目可能具有你们不知道的许可证要求的依赖关系。你们的项目社区，或者你们的雇主政策也可能要求你们使用特定的开源许可协议。 公开的 GitHub 项目是开源的吗？当你们在 GitHub 上创建一个新项目 时，你们可以选择将仓库设置成 private 或者 public。 Making your GitHub project public is not the same as licensing your project. Public projects are covered by GitHub’s Terms of Service, which allows others to view and fork your project, but your work otherwise comes with no permissions.让你们的 GitHub 项目公开与许可你们的项目是不同的。公开项目是由 GitHub 的服务条款保护，它允许他人浏览以及 fork 你们的项目，但是没有权限参与你们的工作。 如果你们想让他人使用，复制，修改你们的项目，或者参与贡献你们的项目，那么你们的项目就需要包含一个开源许可协议。例如，即使你们的项目是公开的，但没有你们的授权，一些人是不能合法在他们的代码中使用你们 GitHub 项目中的任何部分。 请告诉我该如何保护项目你们很幸运，开源许可协议已经标准化了同时使用简单。你们可以直接复制粘贴一个已经存在的许可协议到你们的项目里。 MIT，Apache 2.0 和 GPLv3 都是非常流行的开源许可协议，但是也有其它选择。你们可以在 choosealicense.com 上找到这些许可协议的全部文本，同时说明了如何使用他们。 当你们在 GitHub 上创建了一个新项目，你们会被要求添加一个许可协议。 一个标准化的许可协议可以作为没有法律培训的人员的代理，以准确地知道他们可以和不能用软件做什么。除非绝对要求，否则应避免使用定制，修改或非标准术语，这将成为他人使用代码的障碍。 — @benbalter, “Everything a government attorney needs to know about open source software&nbsp;licensing” 哪个开源许可协议适合我的项目？如果你们是小白，那么使用 MIT License，不容易出错。它很短，很容易理解，并允许任何人做任何事情，只要他们保留许可证的副本，包括你们的版权声明。如果你们需要，您们能够根据不同的许可协议发布项目。 然而，为项目选择合适的开源许可协议这取决于你们。 你们的项目非常可能有（或将有）依赖。例如，如果你们开源了一个 Node.js 的项目，你们将可能使用来自 npm（Node Package Manager）的库。你们依赖的这些库都有它们自己的开源许可协议。如果他们的许可协议“允许”（对使用，修改和分享给予公共权限，而对有关项目的许可协议没有要求），这样你们就可以使用任何你们想要的许可协议。共同允许许可协议包括 MIT，Apache 2.0，ISC 和 BSD。 另一方面，如果你们的依赖中有一个的许可协议是“强硬的 copyleft”（他们也给同样的允许，但条件是有关项目得使用同样的许可协议），那么你们的项目将使用与之相同的许可协议。copyleft 许可协议包括 GPLv2，GPLv3 和 AGPLv3。 你们也会想到考虑希望你们的社区使用以及贡献你们的项目： 你们是否想让你们的项目成为其它项目的依赖？在你们的相关社区最好尽可能使用最流行的许可协议。例如，MIT 是 npm libraries 使用的最流行的许可协议。 你们的项目是否想吸引大企业？大型企业可能需要所有贡献者的明确专利许可。在这种情况下，Apache 2.0 适合你们。 你们的项目是否想吸引不愿自己的贡献用于其它同类型软件的贡献者？GPLv3 和 AGPLv3 适合你们。 你们的公司可能为自己的项目准备了特定的许可协议。例如，它可能需要许可许可证，以便公司可以在公司的闭源产品中使用你们的项目。或者你们的公司要求强大的 copyleft 许可协议同时要求贡献者赞成，这样项目只属于你们公司，没有人能在有关的软件中使用你们的项目。或者你们的公司可能有与标准，社会责任或透明度相关的某些需求，其中任何一个都可能需要特定的许可策略。与你们公司的法律部门谈谈。 当你们在 GitHub 上创建了一个新项目，它给你们提供了选择许可协议的机会。包括上面提到的可以使你们的 GitHub 项目开源的许可协议。如果你们想要了解其他选择，可以通过查阅 choosealicense.com 找到适合你们项目（即使它不是软件）的许可协议。 如果我想更换项目的许可协议，该怎么办？大多数项目绝不需要更换许可协议。但是情况偶尔有变。 例如，随着你们项目的壮大，它添加了新的依赖或用户，或者你们的公司改变了策略，或者其他的要求要更换不同的许可协议。如果你们在开始项目的时候没有添加许可协议，那么再添加一个许可协议和更换许可协议是一样的效果。当你们要添加或者更换项目的许可协议时，需要考虑以下三件事： 这件事很复杂。确定许可协议的兼容性和合规行，以及谁拥有版权，这会非常快速地变得复杂和混乱。为新的发布和贡献选择一个新的且合适的许可协议与重新许可已存在的贡献是不同的。一旦你们有任何想改变许可协议的想法，请首先让法律团队知道。即使你们已经或者能获得可以更换许可协议的权限，请考虑者会给项目的其他用户和贡献者带来怎样的影响。将更换许可协议视为“管理事件”，只有通过与项目的利益相关者进行明确的沟通和咨询，才更有可能顺利进行。请谨记，从一开始就为你们的选择和使用合适的许可协议。 你们的项目已经有了许可协议。如果项目的现有许可证与您要更改的许可证兼容，则可以开始使用新许可证。这是因为如果A许可协议与B许可协议兼容，你们将遵守A的条款，同时遵守B的条款（但不一定反之亦然）。因此，如果你们目前正在使用许可型的许可协议（例如 MIT），则可以更改为具有更多条件的许可协议，只要你们保留 MIT 许可协议的副本和任何相关的版权声明（即继续遵守 MIT 许可协议的最低条件）。如果你们现在的许可协议不是许可型的（例如，copyleft 或者你们还没有许可协议）以及你们不是版权的唯一所有者，那么你们不能将许可协议改为 MIT。基本上，只要是使用的许可型的许可协议，版权所有者能事先更换许可协议。 你们的项目已经有版权所有者。如果你们是你们项目的唯一贡献者，然后你们或者你们的公司是项目版权的唯一所有者。你们可以添加或更换任何你们或者你们公司心仪的许可协议。不然你们需要取得其他版权所有者的同意。他们是谁？他们是已经参与你们项目提交的人。但有些情况是项目版权掌握在这些人的雇主手中。在某些情况下，人们只是做了微小的贡献，但没有硬性规定，在一些行代码下的贡献不受版权保护。对与这样的情况该怎么办？对于一个相对较小以及年轻的项目来说，取得所有贡献者对更换许可协议的同意是可行的。。但对于大项目和老项目来说，你们必须寻求很多贡献者以及他们继承者的共识。Mozilla 花费了多年重新授权 Firefox，Thunderbird 和相关软件。 或者，你们可以让贡献者事先同意（通过额外的贡献者协议 - 见下文）在某些条件下更改某些许可协议，这些更改将超过现有的开源许可协议。这会改变许可协议改的复杂性。如果在执行许可协议更改时，你们仍然想要和项目利益相关者进行沟通，你们需要从你们律师那得到更多帮助。 我的项目需要额外的贡献者协议吗？]可能不要。对于大多数的开源项目，一个开源许可协议可作用与所有贡献者和用户。 贡献者协议会给维护者带来额外的管理工作。这些协议增加了多少工作得取决去项目和实施。简单的协议可能要求贡献者确认和点击，在项目的开源许可协议下他们有权利贡献。更复杂的协议可能需要法律的审查和贡献者的雇主的签字。 此外，贡献者协议有时被认为对项目社区不友好。他们也增加了人们参与社区的障碍。 我们已经删除了 Node.js 的 CLA。这样做降低了 Node.js 贡献者的参与门槛，从而吸引更多的贡献者。 — @bcantrill, “Broadening Node.js Contributions” 一些情况下你们可能想要为你们的项目考虑一个额外的贡献协议： 你们的律师想要所有的贡献者明确接受贡献者条款，或者因为他们觉得只有开源许可协议还远远不够。如果这是唯一的问题，那么有肯定项目开源许可协议的贡献者协议就足够了。jQuery 个人贡献者许可协议就是一个很好的轻量级的个人贡献者协议。对于一些项目来说，Developer Certificate of Origin 是一个很好的先择。 你们的项目使用的开放源许可协议不包括明确的专利授权（如 MIT），你们需要所有贡献者的专利授权，这些可能适合用于你们公司的专利组合或者项目的其他贡献者和用户。Apache 个人贡献者许可协议是一种常用的附加贡献者协议，其具有与 Apache 许可 2.0 中的专利许可相同的专利许可。 如果你们的项目使用的是 copyleft 许可协议，但你们也需要分发项目的专有版本。那你们需要每个贡献者分配版权给你们或者授予你们许可权。MongoDB 贡献者协议就是这中类型的。 你们认为你们的项目在其有效期内需要更换许可协议，以及事先得到贡献者的同意。 如果您们实需要在您的项目中使用额外的贡献者协议，请考虑使用诸如 CLA 助手之类的集成，以最大限度地减少贡献者的分心。 我的公司的法律团队需要知道什么？作为一名公司的雇员，如果你们在发布一个开源项目，你们首先需要让法律团队知道。即使只是一个个人项目，请考虑让他们知道。你们可能和公司有一个“员工知识产权协议”，这给了公司一些对你们项目的控制权，特别是当项目和公司的业务有着很多的联系或者你们使用公司的资源发展项目。你们的公司_应该_很容易给们许可，也许已经通过一个员工友好的知识产权协议或公司政策。如果不是这样，你么可以谈判（例如，解释你们的项目为公司的专业学习和发展目标服务），或者你们在找到一个更好的公司前停止你们项目的工作。 如果你们的开源项目是为了你们的公司，者绝对需要让他们知道。根据公司的业务需求和专业知识，你们的法律团队可能已经制定了有关开放源代码许可协议（以及可能还有其他贡献者协议）的政策，以确保您的项目符合其依赖关系的许可协议。如果不是这样，你们和他们很幸运！你们的法律团队应该渴望与你们合作，把这个东西搞清楚。你们需要思考这些事： 第三方资源：你们的项目有其他人创建的依赖或者使用他人的代码？如果这些事开源项目，你们需要遵守第三方资源的开源许可协议。首先，选择与第三方资源的开放源许可协议一起使用的许可协议（见上文）。如果你们的项目修改或者发布第三方开源资源，那么你们法律团队还想知道你们符合第三方开源许可协议的其他条件，例如保留版权声明。如果你们使用了其他没有开源许可协议的代码，那么你们可能会要求第三方资源的维护者添加一个开源许可协议，要是你们得不到许可，你们只能停止使用他们的代码。 商业机密：请考虑项目中是否有公司不想对外公开的东西。如果是这样的话，你们只能开源项目的一部分，得保护好公司的商业机密。 专利：你们公司是否申请了与你们项目有关的专利？如果开源源代码，这会对公司的专利进行公开披露。可悲的是，你们可能被要求等待（或者公司会重新思考应用程序）。如果你们期望从拥有大量专利组合的公司的员工那里得到贡献，们的法律团队可能希望你们使用来自贡献者的明确专利授权的许可协议（例如 Apache 2.0 或 GPLv3）或其他贡献者协议（见上文）。 商标：认真检查你们的项目名没有与已经存在的商标冲突。如果你们将自己公司的商标用于项目，请检查它有没有造成冲突。FOSSmarks 是在自由和开源项目的背景下理解商标的实用指南。 隐私：你们的项目是否收集了用户数据并存储到公司的服务器？你们的法律团队可以帮助你们遵守公司政策和外部法规。 如果你们发布了公司的第一开源项目，为了能通过，以上这些绰绰有余（不要担心，大多数项目不会引起重大关注）。长期来说，们的法律团队可以做更多的事情，以帮助公司从开源中获得更多，并保持安全： 员工贡献策略：考虑制定一个公司策略，指明你们的员工如何为开源项目贡献。明确的政策将减少你们员工的迷惑，并帮助他们为公司的最佳利益向开源项目做贡献，无论是作为他们工作的一部分还是在自由时间。Rackspace的Model IP和开源贡献策略就是很好的示例。 放弃与补丁相关的只是产权以构建员工知识库和信誉。它表明，公司关心员工的发展，以及让员工有种被赋权和自主的感觉。所有这些好处还导致更高的士气和更好地保留员工。 — @vanl, “A Model IP and Open Source Contribution Policy” 发布什么：（几乎） 所有？如果你们的法律团队了解并投资于你们公司的开源策略，他们将是你们最好的帮助，而不是阻碍你们的努力。 合规性：即使你们公司没有发布任何开源项目，他们也会使用别人的开源软件。意识和过程可以避免麻烦，产品延迟发布和诉讼。 组织必须具有适合[“允许”和“copyleft”]类别的许可协议和合规性策略。首先，记录适用于你们所使用的开源软件的许可条款（包括子组件和依赖项）。— Heather Meeker, “Open Source Software: Compliance Basics And Best Practices” 专利：你们的公司可能希望加入开放发明网络，一个共享的专利防御池，以保护成员使用主要开源项目，或探索其他替代专利许可。 管理：特别是当如果将项目转移到公司以外的法律实体是有意义的。","tags":[{"name":"GitHub","slug":"GitHub","permalink":"http://yoursite.com/tags/GitHub/"}]},{"title":"你们的行为准则 【GitHub 开源贡献指南译文】","date":"2018-03-24T07:20:17.000Z","path":"2018/03/24/你们的行为准则-【GitHub-开源贡献指南译文】/","text":"我为什么需要行为守则？行为守则是一份确立项目参与者行为规范的文件。采用和执行行为守则可以帮助你们的社区营造积极的氛围。 行为守则不仅帮助保护你们的参与者，同时还有你们自己。如果你们维护一个项目，随着时间的推移，可能会发现其他参与者懒散的态度会让你们疲惫或对工作不满意。 一份行为守则可以帮助你们促进健康，有建设性的社区行为。积极主动减少你们或其他人在你们的项目中变得疲劳的可能性，并帮助你们在有人做出你们不同意的事情时采取行动。 建立行为守则尽可能早地建立行为守则，当你们第一次创建项目的时候。 此外，说出你们的要求。行为守则的描述遵循如下几点： 行为守则在哪里有效 (只在 issues 以及 pull requests，或者社区活动？) 行为守则适用于谁 (社区成员以及维护者，那赞助商呢？) 如果有人违反了行为守则会怎样？ 大家如何举报违规 无论你们在哪里，请使用已有的行为守则。贡献者盟约是一个被超过 40，000 个开源项目（包括 Kubernetes, Rails 和 Swift）所使用的行为守则。 Django 行为守则 和 Citizen 行为守则都是非常好的行为守则。 请将 CODE_OF_CONDUCT 文件放在你们项目的根目录，并在 README 中附上其链接，这样对你们的社区是可见的。 决定你们如何执行行为守则 一份行为守则没有（或者不能）执行会比没有行为守则更糟糕。它释放这样一个信息：行为守则或者尊重在你们的社区并不重要。— Ada Initiative 你们应该解释如何执行行为守则在违规发生之前。有几点理由说明为什么这么做： 必要的时候，它表示你们处事认真谨慎。 你们的社区会因为投诉确实可以得到回复而更加放心。 如果他们发现自己因为违规而被调查时，你们能确保社区的审查流程是公平透明的。 你们可以给大家一个私有的渠道（如 email 地址）以便大家报告违规行为以及解释谁收到了这一的报告。它可以是维护者，一组维护者或行为守则工作组。 请不要忘记了有人可能想要报告某些人违规接受了这些报告。在这样的情况下，也给他们举报那些人的机会。例如，@ctb 和 @mr-c 在他们的项目上解释， khmer： 对于滥用现象，扰乱或者其他不可接受的行为都可以向 **khmer-project@idyll.org（仅由 C. Titus Brown 和 Michael R. Crusoe 处理）发送邮件。要报告涉及其中任何一个的问题，请电邮 Judi Brown Clarke，Ph.D.** BEACON 行动进化研究中心的多元化主任，NSF 科学技术中心。 为了获得灵感，可以查阅 Django 的执行手册（你们是否需要如此详细的手册，这取决于你们的项目）。 执行你们的行为守则有时，尽管你们尽了最大的努力，仍然会有人违反守则。当这样的情况发生时，有几种方法来解决消极或有害的行为。 搜集有关违规的信息认真对待社区中每个成员的想法。如果你们收到有人违规的报告，请认真对待并调查此事，即使它不符合你们自己的经验。这样做可以向你们的社区表面，你们珍视他们的观点和信任他们的判断。 有的社区成员可能是让大家一直不舒服的惯犯，或者他们只是说了或做了一次。这都需要依据实际情况进行处理。 在你们做出回应之前，请认真思考发生了什么事。通过阅读他们过去的评论和对话可以更好地理解他们为什么要那样做。尽量收集其他人对他们行为的看法。 不要陷入争论。在你们处理完手头上的事情之前，不要侧重于处理别人的行为。专注于你们需要什么。— Stephanie Zvan, “So You’ve Got Yourself a Policy. Now What?” 采取适当的行动当搜集和处理足够的信息后，你们需要决定做什么。当你们在考虑下一步的时候，请牢记你们的目的是营造一个安全，尊重和协作的社区氛围。不仅要考虑如何处理有问题的情况，还要考虑们的反应将如何影响你们社区的其他行为和期望。 当有人报告违规时，处理它是你们的工作，而不是他们的。有时，报告者透露他们的信息会给他们的职业生涯，声誉和人生安全带来很大的风险。迫使报告者面对骚扰者会将他们置于妥协的位置。除非报告者有特别的要求，你们应该直接和有问题的人沟通。 这里有些方法帮助你们回应违规行为： 向相关人员发出公开警告以及解释他们的行为产生了怎样的负面影响，最好在发生问题的地方。在可能的情况下，公开沟通会向社区的其他人传达你们认真对待行为守则。要友善，但坚定的沟通。 私下接触相关人员向他们解释他们的行为对其他人产生了怎样的负面影响。如果相关情况涉及到个人敏感信息，你们可能会使用私有通信方式。如果你们和一些人私下沟通，对于首先报告这个情况的CC来说是个好主意，因为他们知道你们采取了行动。在征求他们的意见之前，请向报告人征求同意。 有时，一个解决方案不能达到目的。有关的人可能在面对或者不改变他们的行为时变得气势汹汹或敌对。在这种情况下，你会想到考虑采用强制措施。例如： 暂停有关人员在项目中的工作，通过暂时禁止参与项目的任何方面执行 永久禁止有关人员加入项目 对于禁止成员的做法，你们应该非常谨慎，只有在没有其他解决方案的情况下才能使用。 维护者的责任和义务行为守则不是可以任意执行的法律。你们是行为守则的执行者，同时你们的责任是遵守行为守则确立的规矩。 作为维护者，你们可以为社区指定准则，同时你们可以根据行为守则执行这些准则。这意味着你们需要认真处理违规行为。报告者对他们的投诉进行了彻底和认真地审查。如果你们确定他们报告的行为没有违规，你们需要他们进行沟通并解释你们为什么不进行处理。他们会怎样做，取决于他们：容忍他们认为有问题的行为，或者停止参与社区。 如果报告的行为没有技术上的违规，这可能表面你们的社区依然存在问题，同时你们应该调查潜在的问题以及采取相应的行动。这可能包括修改你们的行为守则，以澄清可接受的行为和/或与行为被举报的人交谈，并告诉他们，虽然他们没有违反行为守则，但是他们在期望和确定的边缘另其他参与者感到不舒服。 最后，作为维护者，你们给可接受的行为建立和执行标准。你们有能力塑造项目社区的价值观，以及参与者希望你们能 公平公正地执行这些价值观。 鼓励你们希望看见的行为 🌎当你们的社区变得似乎敌对或者不受欢迎时，即使是一个大家能容忍的个人行为，也会让你们失去很多贡献者，你们可能再也遇不到其中的一些人。虽然执行或者采用行为守则很难，但是营造一个受欢迎的环境将帮助你们社区成长。","tags":[{"name":"GitHub","slug":"GitHub","permalink":"http://yoursite.com/tags/GitHub/"}]},{"title":"领导和管理开源项目【GitHub 开源贡献指南译文】","date":"2018-03-24T07:14:15.000Z","path":"2018/03/24/领导和管理开源项目【GitHub-开源贡献指南译文】/","text":"学会管理成长中的项目你们的项目正在成长，也有人参与进来，你们承诺保持这样的状态。在这个阶段，你们可能想知道如何将常规项目贡献者纳入你们的工作流程，无论是否给他们提交权限或者解决社区辩论。如果你们有疑问，我们给出了答案。 在开源项目中使用正式角色的示例有哪些？许多项目遵循类似的贡献者角色和认可结构。 这些角色实际上意味着什么，完全取决于你。这里有一些你可能认识的角色类型： Maintainer（维护者） Contributor（贡献者） Committer（提交者） 对于一些项目来说，”maintainers” 是在项目中有提交权限的人。在其他项目中，他们是作为维护者被名字被列在 README 中的人。 维护者不一定要是为项目编码的人。他可能是为你们项目的宣传做了很多工作的人，或者是为项目编写文档以方便其他人使用的人。无论他们每天做了什么，维护者是对项目的方向有责任感以及致力于改善项目的人。 一名 “contributor” 可以是任何评论过 issue 或者 pull request 的人，给项目带来价值（无论是对 issues 进行分类，编码，或者组织活动）的人，或者任何合并过 pull request 的人（可能是贡献者最狭隘的定义）。 对于 Node.js 来说，项目社区中的每个人都参与评论 issue 或者提交代码。这意味着他们从用户过度到了贡献者。 — @mikeal, “Healthy Open Source” 术语”提交者”可能是用于区分提交权限，它是一个有着明确责任的角色类型，来自其它形式的贡献。 虽然你们可以以任何你们想要的方式定义项目角色，但请考虑使用更广泛的定义来鼓励更多来自其他形式的贡献。你们可以利用管理者的身份认识为项目做出特别贡献的人，不论他们的技能是什么。 你们可能认为我是 Django 的“发明者”…但事实是当她诞生一年后我才参与这份工作。（…）人们怀疑我成功了，因为我的编程技能…但我最多只是个普通的程序员。 — @jacobian, “PyCon 2015 Keynote” (video) 我如何正式化这些领导者角色？正式化你们的领导者角色能够帮助人们有归属感并告诉社区中的其他成员他们可以向谁寻求帮助。 对于小项目来说，指派领导者可以和将他们的名字添加到你们的 README 或者 CONTRIBUTORS 的文本文件中一样简单。 对与比较大的项目来说，如果你们有网站，可以创建一个团队网页或者将你们项目的领导者们排列在上面。例如 PostgreSQL 有一个详细的团队页面并有每个贡献者的简单信息。 如果你们的项目有个非常活跃的社区，你们可能形成一个维护者的“核心团队”，甚至拥有来自不同 issue 领域（例如：安全，issue 分类或者社区准则）的人组成的小组委员会。让大家自己组织并志愿选择他们喜欢的角色，而不是分配给他们。 我们补充了核心团队和几个“子团队”。每个子团队专注于一个特定领域（如：语言设计或者库）。（。。。）为了整个项目的协作和强大，每个团队的愿景要与整个项目愿景保持一致，每个子团队由一名来自核心团队的成员领导。— “Rust Governance RFC” 领导者团队可能想要创建一个指定的通道（像 IRC）或者定期会面来讨论项目（像 Gitter 或者 Google Hangout）。你们甚至可以组织这样的公开会议以便其他人参与。例如，Cucumber-ruby 的每周办公时间。 一旦你们建立了领导者角色，请记得以文档的形式记录告诉大家如何联系他们！给大家如何成为你们项目的一名维护者或者仅仅是加入一个子委员会建立一个清晰的流程，并将之写进你们的 GOVERNANCE.md 中。 有些工具像 Vossibility 可以帮助你公开跟踪谁给项目了贡献（或者没有）。记录这些信息可以避免社区认为维护者是一个团体，可以私下作出决定。 最后，如果你们的项目在 GitHub 上，请考虑将你们的项目从个人账号转移到一个组织并添加至少一个备份管理员。GitHub 组织 我什么时候应该给一些人提交权限？一些人认为你们应该给所有参与贡献的人提交权限。这么做能够让更多的人对项目有归属感。 一方面，特别是对于比较大，很复杂的项目，你们可能只想把提交权给那些已经表示了忠心的人。这种事没什么对错，你们开心就好！ 如果你们的项目在 GitHub 上，你们可以利用受保护的 branches管理谁可以在什么情况下像某个特定的 branch 进行 push。 无论什么时候有人向你们发送一个 pull request，请给他们你们项目的提交权限。虽然这听上去非常愚蠢，但是使用这样的策略能够让你们充分利用GitHub的优势。（。。。）一旦大家有了提交权限，他们就 不用再担心他们的补丁没有合并了…造成他们浪费了大量的时间。 — @felixge, “The Pull Request Hack” 开源项目的一些常见治理结构有哪些？这里有三个与开源项目有关的常见治理结构。 BDFL:SDFL 表示 ”Benevolent Dictator for Life（仁慈的独裁者的生活）”。在这个模式下，只有一个人（通常是项目的作者）对项目的主要决议有最终得决定权。Python 就是一个经典的示例。小项目一般默认是 BDFL，因为他们只有一两个维护者。如果是公司的项目可能也会使用这中策略。 Meritocracy（精英）: (注意：这个术语 “meritocracy（精英）”对一些社区来说带有消极的意味，同时用有一个复杂的社会以及政治历史。)在精英模式下，活跃的贡献者（展示”价值”的人）被赋予了一个正式的决策者角色。决议通常是通过纯投票的形式抉择。这个权威的概念是由 Apache Foundation 首创；所有 Apache 的项目都是精英。贡献仅由他们个人提供，而不是公司。 Liberal contribution（自由贡献）:在自由贡献模式下，做最多工作的人被认为是最有影响力的，但是是以现在的当前工作为基准而不是过去的贡献。项目的主要决议都是通过寻求共识的方式得到的，而不是以纯投票的形式，并努力考虑社区中更多的观点。使用自由贡献模式非常流行的示例包括：Node.js 和 Rust。 你们应该选择哪种？这取决于你们！每种模式都有有点以及需要权衡之处。虽然咋一看他们有着很大的不同，但是他们的共同点要比看上去的多。如果你们有兴趣采用其中的一种模式，可以浏览这些模板： BDFL model template Meritocracy model template Node.js’s liberal contribution policy 当我的项目启动时我需要编写管理文档吗？虽然没有合适的时间写下你们项目的管理文档，但一旦你们看到你门的社区动态表现，它就容易定义了。开源管理的最好（最难的）部分是它是由社区塑造的！ 一些早期文档不可避免的是用于你们项目的管理。所以，开始写下你们可以写的。例如，在你们项目启动的时候你们可以清晰地说明期待什么样的行为，或者你们的贡献者如何处理工作。 如果你们是参与公司开源项目启动的成员，在项目发布之前，你们有必要进行内部讨论，了解你们的公司如何保持并决定项目的进展。你们也可以公开解释贵公司将如何（或不会）参与该项目的任何事情。 我们分配小团队来管理GitHub上的项目，他们实际上在 Facebook 工作。例如，React 是由一位 React 工程师管理。 — @caabernathy, “An inside look at open source at Facebook” 如果公司的员工开始提交贡献会发生什么？成功大开源项目会被很多人和公司使用，以及甚至有些公司的收入会与这些项目有关。例如，公司可能使用开源项目中大代码作为他们商业服务的一部分。 随着项目被广泛地使用，会需要更多具有专业知识的人，你们可能就是他们中的一个！同时，有时大家在为项目工作时会得到报酬。 重要的是平常心对待商业活动，并且将之视作其他资源发展的动力。当然，不应该区别对待有报酬的开发者和其他无薪酬的；每个贡献都应该根据其技术特点进行评估。然而，大家应该开心地参加商业轰动；同时当争论对项目有利时，大方地陈述他们的用例。 “商业”和“开源”是兼容的。“商业”仅仅是意味着有金钱的参与，软件被用于商业，这有利于项目的发展和推广。（虽然非开源产权中使用了开源软件，但整个产品依然是“专利”软件。开源可以用于商业或者非商业目的。） 和任何人一样，具有商业动机的开发者也是通过他们贡献的质量和数量提高影响力的。很明显，得到报酬的开发者可能会比没有报酬的做的更多，但这是被允许的；金钱只是影响一些人做少事情的很多因素中的一个。让你们的项目讨论侧重于贡献，而不是关注使人们能够做出贡献的外部因素。 我需要一个法律顾问来支持我的项目吗？你们不需要法律顾问来支持你们的开源项目，除非涉及到金钱。 例如，如果你们想创建商业业务，你们将要建立 C Crop 或者 LLC （如果你们位于美国）。如果你们只是做与你们的开源项目相关的合同工作，你可以作为独资经营者接受金钱，或设立一个 LLC（如果你在美国）。 如果你们的开源项目想要接受捐赠，你们可以设置一个捐赠按钮（例如使用 PayPal 或者 Stripe,还有中国的支付宝和微信支付），除非您是符合条件的非营利机构（如果您在美国），否则这笔钱不会免税。 很多项目为了省去建立非盈利机构的麻烦而去找一家非营利机构赞助他们。非营利机构代替你们接受捐赠，但你们需要给他一定比例的捐款。自由软件保护, Apache 基金会, Eclipse 基金会, Linux 基金会 和 Open Collective 都是为开源项目提供赞助的组织。 我们的目的是提供可被商业持续使用的基础设施，因此创造一个每个人（包括贡献者，支持者，赞助者）都能受益的环境。 — @piamancini, “Moving beyond the charity framework” 如果你们的项目与某种特定的语言或者生态系统联系紧密，那么你们可以和与之相关的基金会合作。例如，Python 软件基金会帮助支持用于管理 Python 包的 PyPI，Node.js 基金会帮助支持一个 Node 基础框架项目 Express.js。","tags":[{"name":"GitHub","slug":"GitHub","permalink":"http://yoursite.com/tags/GitHub/"}]},{"title":"建立受欢迎的社区 【GitHub 开源贡献指南译文】","date":"2018-03-23T15:53:45.000Z","path":"2018/03/23/建立受欢迎的社区-【GitHub-开源贡献指南译文】/","text":"建立成功的项目你们已经启动了你们的项目，你们正在传播它，同时有人正在查看它。真棒！现在，你如何让他们坚持下去。 一个受欢迎的社区是对你们项目的未来和声誉的投资。如果你的项目才开始收到第一次贡献，那么你们需要尽早的给贡献者们一次积极的经历，以至于能让他们继续参与贡献。 让大家感到受欢迎可以通过被 @MikeMcQuaid 称之为贡献者漏斗的方法思考你们项目的社区。 当你们建立了自己的社区，你需要考虑如何让那些处在漏斗上方的人（潜在用户）转移到漏斗下方（活跃的维护者）。你们的目标是减少贡献者们在每个阶段遇到的摩擦。当人们能够轻易的取得胜利时，他们会乐意去做更多事。 从你的文档开始： 让大家很容易使地用你的项目。 一份友好的 README 以及清晰的代码示例将让大家很简单地开始你们的项目。 清楚的解释如何做贡献，使用你的 CONTRIBUTING file 以及持续更新 issues。 好的文档能够邀请他人参与你们项目的互动。最终，一些人会开一个 issue 或者 pull request。将这些互动视为机会，将他们转移到漏斗的下方。 当一些人选择了你们的项目，请对他们表示感谢！仅仅只是一次消极的经历就能让一些人不想再回来。 及时回应。如果你们一个月都没有回答他们的问题，他们可能早已忘记了你们的项目。 对你以后接受的所有贡献者持开放态度。 很多贡献者是从一份 bug 报告或者小的修复开始的。这里有很多为项目做贡献的方式。让大家选择他们喜欢的方式。 如果你不赞成一个贡献， 首先你需要对他们的想法表示感谢，同时 解释为什么它不适合项目，如果有必要的话你可以给出相关的文档链接。 为开源做贡献对一些人来说很简单，但对另外一些人可能就不是这样了。有很多人因为没有做正确的事而害怕叫喊，或者只是不适合。（。。。）通过允许贡献者参与一些对技术要求比底的工作（文档，web content markdown，etc），可以极大的减少你对这些情况的关注。 — @mikeal, “Growing a contributor base in modern open source” 多数开源贡献者是“临时贡献者”，因为他们只是偶尔参与项目贡献。一位临时贡献者可能没有充足的时间全程跟踪你的项目，所以你们的工作是能让他们很容易地参与贡献。 鼓励其他的贡献者也是对你们项目的一种投资。当你们授权大量的粉丝做他们感兴趣的工作时，你们的压力就少了很多。 记录一切 你是否参加过一个（技术）活动，你不认识在场的人，但是似乎每个人站在一个小组里像老朋友一样聊天？（。。。）现在想象下你想为一个开源项目做贡献，但是你不知道为什么或者这个是如何发生的。 — @janl, “Sustainable Open Source” 当你开始一个新项目，你会觉得保持工作的私有性是正常的。但是开源项目发开始于你在公共平台记录自己的工作进程。 当你门把事情记录下来，会有更多的人能够按照你们的方式参与每一步。你可能会得到意想不到的帮助。 书写东西不仅仅只是技术文档。任何时刻，你们有写一些东西或者私自讨论项目的冲动，请询问自己是否能将之公开。 保持项目透明的项目路线：你们期待什么类型的贡献者，如何审查贡献，或者你们为什么做某些决定。 如果你们注意到有多个用户遇到过同样的问题，那么你们应该将答案记录在 README 中。 对于经常遇到的问题，你们可以考虑发布你们的笔记或者相关的 issue。在这种情况下得到的反馈将会令你们惊讶。 记录一切也适用于你们的工作。如果你正在进行大量的更新工作，请将其放入 pull request 并标记为正在进行（WIP）。这样，可以让其他人感觉参与过早期工作。 积极回应一旦你推广项目，人们将会给你们反馈。他们可能会问项目是如何工作的，或者需要你们帮助开始项目。 当有人列出一条 issue，提交一个 pull request，或者询问项目的有关问题时，你们应该尽量回答他们。当你们快速地做出回应时，人们将感觉到他们参与了对话，以及他们将会更热情地参与。 如果你无法及时审查请求，请尽早确认，这样会有助于提高参与度。这里是 @tdreyno在 Middleman上如何回应一个 pull request： 一份 Mozilla 研究发现 如果贡献者在 48 小时内收到代码审查，他们会有很大的可能返回以及重复贡献。 与你们项目有关的话题也可能发生在互联网的其它地方，例如 Stack Overflow，Twitter，或者 Reddit。你门可以在像这样的一些网站设置通知，这样当有人提及你们项目时可以收到提醒。 为你们的社区提供一个聚会的场所有两个理由可以解释为什么要给社区提供一个聚会的场所。 第一个理由是为了他们。帮助人们相互认识。有着共同兴趣的人会想要一个可以聊天的地方。同时当信息是公开的而且是适宜的时候，任何人可以阅读过去的档案以至于能够快速的追赶以及参与。 第二个理由是为了你们。如果你们没有提供一个公共的场所来谈论你们的项目，他们可能会直接与你们联系。刚开始时，回复私有来信可能对你们来说很轻松。但是经过一段时间后，尤其是如果你们的项目变得流行的时候，你们就会感到累了。不要私下和人们谈论你们的项目，而是直接指明他们去指定的公共渠道。 公共交流和指明人们开一条 issu 一样简单，而不是直接发给你们发邮件或者在你们的博客发表评论。你们也可以为了方便人们谈论你们的项目设置一个邮件列表，或者创建一个 Twitter 账号，Slack，护着 IRC 渠道。或者尝试上述的所有方式。 Kubernetes kops sets aside office hours every other week to help community members:Kubernetes kops 每隔一周抽出办公时间帮助社区成员： Kops 每隔一周都会留出时间为社区提供帮助和指导。Kops 维护者已经同意留出时间专门与新手一起工作，帮助 PRs，以及讨论新特性。 公开交流需要特别注意的异常有：1）安全的 issues 和 2）敏感的行为准则。你们应该为大家提供一个私下报告这些 issue 的方式。如果你们不想使用自己的个人邮箱，那么就创建一个准用邮箱。 让社区成才社区非常有能量。这种能量可能是祝福也可能是诅咒，这取决于你们如何执掌它。随着你们项目社区的成长，有办法帮助它成为一股有建设性的力量，而不是具有破坏性的。 不要容忍糟糕的角色一些流行的项目将不可避免地回吸引来一些伤害它们的人。他们可能从一些没必要的争论开始，对一些细小的功能进行谬论，或者伤害他人。 对于那种类型的人你们必须采取零容忍的政策。如果发现较晚，那些消极的人将会社区中的其他人不舒服。他们可能会离开。 》事实是，拥有一个支持性社区是关键。如果没有来自我的同事，互联网上一些友好的陌生人，以及聊天渠道 IRC 的帮助，我不可能做好这些工作。（。。。）不要太少。不要找麻烦。 — @karissa, “How to Run a FOSS Project” 定期对你们项目琐碎方便的辩论，使他人，包括你们不能把注意力集中于重要的任务上。新人如果看见这样的情景，他们是不会加入你们项目的。 当你们发现社区中有消极行为时，需要公然指出来。特别说明的是，要用坚定的语气解释他们的行为为什么是不可接受的。如果这种问题继续发生，你们有必要要求他们离开。你们的行为准则是为这些情景准备的建设性指南。 知道贡献者在哪里随着你们项目的成长，好的文档只会变得越加重要。临时贡献者不可能对项目非常熟悉，通过阅读你们的文档他们能很快找到他们需要的。 在你们的 CONTRIBUTING 文件里，需要明确告诉新来的贡献者该如何开始。你们可能为了想要达到这个目的而准备一个专门的部分。 在你们的 issue 列表中，bugs 标签需要适合不同类型的贡献者：例如，“first timers only”, “good first bug”, 或者 “documentation”. 这些标签能够帮助新人快速浏览issues以及开始。最后，使用你们的文档让人们在每一步都感到欢迎。你们永远不会与登陆项目的大多数人互动。你们可能没有收到一些贡献，因为有些人感到害怕或者不知从和开始。即使是几个字也能阻止一些人沮丧地离开你们的项目。例如，这里是Rubinius如何开始它的贡献指南：&gt; 我们想感谢你们使用 Rubinius。这个项目是一个充满爱的劳动，我们希望所有用户查找 bugs，取得性能上的提升，以及帮助完善文档。每一个贡献都是有意义的，所以感谢你们的参与。话虽如此，但我们还是要求你们遵守一些指南，这样我们就能够找到你们的 issue。### 分享你们项目的所有权 你们的领导者们将有不同的观点，因为这是所有健康社区都该做的！然而，你们会体会到粗暴鲁莽的做法不能得到大家的认同，反而谦虚低调的做法更容易让大家接受。 — @sarahsharp, “What makes a good community?” 当大家觉得拥有项目的所有权时，他们会乐意为项目做贡献。这并不意味着你们需要转变项目的愿景或接受你们不想要的贡献。但是你们越信任他们，他们就会越忠诚。 看你们是否能尽快地找出向社区分享所有权的方法。下面有些建议： 反对你们自己修复简单（非关键）的 bugs。 相反，使用它们作为招募新贡献者的机会，或者指导想要参与贡献的人。开始时可能效果不是很理想，但经过一段时间你们会得到想要的结果。例如，@michaeljoseph 要求一位贡献者提交一个 pull request 在一个Cookiecutter issue 的下面，而不是自己修复它。 在项目中添加一个贡献者或者作者文件用于记录每一个参与贡献的人。 如果你们的社区有了一定的规模，那么发送一封信或者发表一篇博客感谢贡献者们。Rust 的This Week in Rust和Hoodie的Shoutouts是两个非常好的示例。 给每个贡献者 commit 的通道。@felixge 发现这样会使大家越发乐意斟酌他们的补丁，以及他甚至发现了他在一段时间没有工作的项目的新维护者。 如果你们的项目在 GitHub 上，那么将项目从你们的个人账号转移到一个组织，以及添加至少一个备份管理员。组织能让与其他人一起工作于同一个项目变得更加容易。 事实上很多项目只有一个或者两个做大量工作的维护者。随着你们的项目以及社区越来越大会更加容易得到帮助。 当你们不能总是发现一些人去回答问题时，你们可以释放一个信号增加其他人能接触到的机会。如果你们能尽早地开始，大家就能尽快地帮助。 你们最大的兴趣是招募喜欢你们项目以及能够做你们不能做的事的贡献者。你喜欢编码，但不喜欢回答 issues？那么让社区中能做这件事的人去做。 — @gr2m, “Welcoming Communities” 解决冲突在你们项目的早期，做主要的决定是件容易的事。你们想做什么就可以做什么。 随着你们的项目越加流行，会有更多的人对你们的决定有兴趣。即使你们的社区没有大量的贡献者，如果你们的项目有很多用户，你们会发现大家的重点在决策上或者增加他们的 issues。 在大多数情况下，如果你们培养了一个友好，尊重的社区并公开记录你的过程，你们的社区应该能够找到解决方案。但有时候你们遇到一个 issue，有点难以解决。 建立友好的氛围当你们的社区正在讨论一个很难的 issue 时，气氛会很激烈。人们可能会变得愤怒或者沮丧，以及发泄在其他人或者你们身上。 作为一名维护者你们的工作是不要让这种情况出现。即使你们对话题有很强烈的观点，也要尽量站在一个主持者或者推动者的位置，而不是参与争吵以及推动自己的观点。如果有人不友好或者垄断话题，那么立即采取行动以保持有礼貌以及丰富的讨论。 作为一名维护者，尊重你们的贡献者非常重要。他们经常处理一些你们描述亲切的事情。 — @kennethreitz, “Be Cordial or Be on Your Way” 一些人希望你们指导他们。编写一个好的示例。你们仍然可以表达失望，不高兴或者忧虑，但得心平气和。 保持你们的酷并不容易，但是展示领导能力能促进健康的社区。互联网感谢你们。 将你们的 README 视为宪法你们的 README 不仅仅是一组指令。它也是一个谈论你们目标，产品愿景和路线的地方。如果人们过分专注于辩论特定功能的优点，它可能有助于重新审视您的 README，并谈论你们的项目的更高的愿景。关注你们的 README 也会使对话变得个人化，所以你们可以进行建设性的讨论。 专注过程，而不是结果一些项目用投票的方式做重要决定。虽然看上去是明智的，投票强调的是得到一个“答案”，而不是倾听以及解决每个人的顾虑。 投票会变成政治，社区成员在做感兴趣的事或者表决一个明确的方法时会感到压力。不是每个人都参与了投票，可能在你们的社区中保持沉默的人占了多数，或者用户不知道投票这件事正在发生。 有时候，投票是必要的手段。尽你们所能强调“寻求共识”而不是共识。 在寻求共识的过程中，社区成员讨论主要问题，直到他们感到他们已经得到充分的意见。当仅遗留下一些无关紧要的问题时，社区需要向前迈进。“寻求共识”不能确保社区能得到一个完美的答案。而是侧重聆听和讨论。 Atom Issues 不存在投票系统的部分原因是因为 Atom 团队在所有情况下都不会遵循投票系统。有时我们必须选择我们认为是对的事，即使它不流行。（。。。）我能通过社区的反馈知道我能够提供什么以及做什么样的工作。 — @lee-dohm on Atom’s decisionmaking process 即使你们不确定是否采用寻求共识的方式，作为维护者，让大家知道你们正在关注他们。让其他人知道，以及承诺解决他们的问题，这在很大程度上减少了敏感情况的发送。然后，按你说的去做。 不要为了获得决议而急于做出决定。在做一个决议之前请确保每个人已经知道以及所有的信息以及公开。 将对话的重点聚焦于行动讨论很重要，但是富有成效和没有效果的对话时有区别的。 鼓励讨论，只要它正积极地朝着解决问题的方向进行着。如果对话已经无法再进行下去，只有很少的人在参与或者大家正在讨论无关紧要的问题，这时候就该结束对话了。 允许这些对话进行下去不仅对解决问题没有帮助，而且不利于社区的健康发展。它释放了这样一个信号，表示允许或甚至鼓励这种类型的对话，它可能阻止人们提高或者解决未来的问题。 当你们或者其他人每提出一个观点时，请自问：“这如何使我们更接近一个决议？” 如果对话开始有解散的征兆，问团队：“我们下一步该做什么?”才能重新对话。 如果一个对话没有清晰的方向，没有明确的措施可以采取，或者合适的措施已经被使用，那么关掉issue并解释为什么关掉它。 指导一件事朝着正确的方向发展是一门艺术。它对阻止人们浪费时间或者要求他们发表有建设性的看法没有作用。（。。。）反而，你们必须为接下来的进展给出条件：给大家一个路线，跟随一个可以得到你们想要的结果的途径，这样就不像是些无用的口头行为。 — @kfogel, Producing OSS 挑战你们的智慧上下文很重要。考虑谁参与讨论，以及他们如何代表社区的其他人。 社区中的每个人都为这个问题而烦恼，或者参与讨论了吗？或者只是一部分人感到困惑吗？不要仅关心活跃的声音，也请不要忘记考虑社区中保持沉默的人。 如果这个问题不代表社区的更广泛的需求，你们可能要承认只是少数人的担心。如果这是一个反复出现的issue，没有一个清晰的解决方案，那么指向他们以前讨论的话题。 找出社区中的决策者通过一个态度端正和目标清晰的对话，很多困难都是可以解决的。即使在富有成效的对话中，对于如何进行的意见也可能存在差异。在这些情况下，确定一个人或一组人，可以作为决策者。 决策者可以是项目的主要维护者，或者是大家投票选出的一个小团体。理想情况下，在你们使用 GOVERNANCE 文件之前，你们已经确定了决胜者和与之相关的事宜。 使用决策者应该是你们最后才能采取的手段。分离 issues 是一个你们社区成长和学习的机会。利用这些机会以及协同合作，尽量找出解决方案。 社区是开源的❤️健康，蓬勃的社区每周都会为开源付出大量辛勤的劳动。许多贡献者指出其他人在开源工作或不在开源工作的原因。通过学习如何建设性地利用这个权力，你们会帮助他人有一个难忘的开源体验。","tags":[{"name":"GitHub","slug":"GitHub","permalink":"http://yoursite.com/tags/GitHub/"}]},{"title":"开启一个开源项目【GitHub 开源贡献指南译文】","date":"2018-03-23T15:29:52.000Z","path":"2018/03/23/开启一个开源项目【GitHub-开源贡献指南译文】/","text":"什么是开源，为什么要开源 那么你正准备拥抱开源吗？恭喜你，开源世界欣赏你的贡献。接下来让我们聊聊什么是开源，我们为什么要开源。 “开源”意味着什么？当一个项目开源后，意味着 不论什么目的，所有人都可以浏览，使用，修改和分发你的项目。 这些权限都是来自于开源协议. 开源非常的强大。因为它降低了使用的门槛，使新奇的思想得到快速的传播。 来理解它如何工作，想象下你的朋友正在吃便当，这时你带来了樱桃派。 每个人都会想要樱桃派（使用） 这个派引起了一场轰动！周围的人会想知道你的烹饪方法（浏览） 有一位朋友 Alex 是一名糕点师，他会建议少放一点糖（修改） 另外一位朋友 Lisa 要求使用它作为下个星期的晚餐（分发） 同样的，闭源就像是你去餐厅必须付钱才能吃樱桃派。但是，餐厅不会告诉你樱桃派的烹饪方法。如果你恰好抄袭了他们的派，并以你自己的名义出售，那么餐厅将会采取行动抵制你。 人们为什么要将他们的工作开源？ 我从开源使用和协作中获得的最有价值的经验之一来自我与其他面临许多相同问题的开发者建立的关系。 — @kentcdodds, “How getting into Open Source has been awesome for me” 这里列举了很多理由 来解释为什么个人或者组织想要开源自己的项目。下面列举了部分： 协作: 开源项目欢迎所有人参与。例如， Exercism是一个有超过 350 人协作开发的练习编程的平台。 采用和重新混合:任何人可以出于几乎任何目的使用开源项目。人们甚至可以将开源项目用于构建其他的项目。例如， WordPress是基于开源项目 b2构建的。 透明度: 所有人都可以检查开源项目中存在的问题。透明度对于政府（如 保加利亚 或者 美国）, 产业调整（如银行业或者医疗健康行业）, 和软件安全（如 Let’s Encrypt）。 不仅仅是可以开源软件，你可以开源一切，从数据集到书籍。通过浏览 GitHub Explore 你可以知道什么东西可以被开源。 开源是否意味着免费?开源最吸引之处就是它不用花钱。然而免费只是开源的价值的一个副产品。 因为 开源协议要求开源项目可以被任何人出于几乎任何目的使用，修改和分享，这些项目一般都是免费的。如果有些开源项目需要付费使用，任何人都可以合法地使用其免费版。 结果是大多数开源项目都是免费的。但免费并不属于开源定义的一部分。开源项目可以通过双重许可协议或者其它的方法进行间接收费，同时不违背开源的官方定义。 我应该发起属于自己的开源项目吗?答案是肯定的，因为不论结果是什么，发起一个属于自己的开源项目是学习开源最好的方法。 如果你还没有开源过一个项目，你可能会因为没有人关注或者别人的说辞而紧张。如果真是这样的话，你并不孤独！ 开源与其他有创意的活动是一样的，无论是写作还是画画。你可能会害怕向世界分享你的工作，但练习是唯一让你变得更好的方法，即使你没有一位听众。 如果你不确信，那么请花一点时间想想你的目标可能是什么。 设定你的目标目标可以帮助你知道该做什么，不因该说什么和需要从他人那里获得哪些帮助。请开始问自己，我为什么要开源这个项目？ 这个问题没有一个正确的答案。你可能为一个简单的项目设定了多个目标，或者不同的项目有不同的目标。 如果你唯一的目的是炫耀你的工作，你可能甚至不想将它贡献出去，甚至不会在 README 中说明。另一方面，如果你想贡献自己的项目，你将会花更多的时间在书写简洁明了的文档上，使新来的参与者感到欢迎。 在某一时刻，我创建了一个自定义的 UIAlertView，并且决定开源。因此我对进行了一些修改使其更加动态灵活，同时上传到 GitHub。我编写了一份技术文档以便其他开发者将 UIAlertView 用于他们的项目中。或许没有人使用这个项目，因为这是一个简单的项目。但是我为自己的贡献感到开心。 — @mavris, “Self-taught Software Developers: Why Open Source is important to us” 随着你的项目的发展，你的社区可能不仅需要你提供的代码。回复 issues，审查代码和传播你的项目在一个开源项目中都是非常重要的任务。 虽然你花费在非编码上的时间取决于项目的规模和范围，但你应准备好作为维护者来自己解决问题或者向他人寻求帮助。 如果你参与了公司的开源项目， 确保你的项目拥有它所需要的内部资源。当项目启动后，你会想知道由谁负责维护和在你的社区如何分享这些任务。 如果你需要为项目的宣传，操作和维护准备一笔专用预算或者人员配置，那么尽早开始讨论。 一旦你开源项目后，最重要的是你要考虑到项目周围社区的贡献和能力。你不必担心一些不是你公司的贡献者参与到项目的关键部分。 — @captainsafia, “So you wanna open source a project, eh?” 为其他的项目做贡如果你的目标是想学习如何与他人一起协作或者了解开源是如何工作的，那么你可以考虑为一个已存在的项目做贡献。开始参与你曾经使用过和喜爱的项目。为项目做贡献就像修改错别字或者更新文档一样简单。 如果你不知道如何开始做一个贡献者，那么可以阅读我们的Github 开源项目贡献指南。 发起属于你的开源项目如果没有充足的时间来开源你的工作，你可以开发一个想法，一个正在进行的工作或者多年后将被关闭的资源。 一般来说，当你发现有人对你的工作反馈了一些有建设性的观点后，你应该开源你的项目。 无论你决定开源你项目的哪个阶段，每个项目都应该包含这些文档： opensource license README opensource guidelines code of conduct 作为一名维护者，这些组合将会有助于你表达想法，管理贡献和保护每个人的合法权益（包括你自己的）。他们大大增加了你获得积极经验的机会。 如果你的项目在 GitHub 上，将这些文件按上面推荐的命名方式放在你的根目录，这样对你的读者会一目了然。 选择协议 开源协议可以保障他人对你的项目进行使用，复制，修改和贡献时不会产生影响。它还保护你免受法律的困扰。当你发起一个开源项目时必须选择一个协议。 法律工作很乏味。好消息是你可以在你的仓库中使用一个已经存在的开源协议。这样你只花了很少的时间，但很好的保护了你的工作。 MIT, Apache 2.0, and GPLv3 都是非常流行的开源协议，但是 还有其它的开源协议 可供你选择。 当你 GitHub 上创建了一个新项目，你可以选择许可协议。包括可以使你的 GitHub 项目开源的协议。 如果你还有其它的疑问或者与开源项目相关的法律问题，请来这里。 编写 READMEREADME 不仅解释了如何使用你的项目，他们还解释了你的项目为什么重要，以及用户可以用它做什么。 在你的 README 中尽量要回答以下的问题： 这个项目是做什么的？ 为什么这个项目有用？ 我该如何开始? 如果我需要使用它，我能从哪里获得更多帮助。 你可以用 README 去回答其它的问题，像你如何处理贡献，项目的目标是什么，开源协议的相关信息。如果你的项目不想接受贡献，或者你的项目不能用于产品，你就可以将这些写在 README 中。 一份好的文档意味着会吸引更多的用户，收到更少的支持请求，得到更多的贡献。（···）请记住你的读者们不是你。参与同一个项目的开发者们有着完全不同的经历。 — @limedaring, “Writing So Your Words Are Read (video)” 有时候，人们不会去编写 README。因为他们觉得项目还没有完成或者他们不想要贡献。这些都是非常好的为什么要编写 README 的理由。 为了获得更多的灵感，可以尝试使用 @18F’s “编写可阅读的 README” 或者 @PurpleBooth’s README 模板去编写一份 README。 当你的根目录中包含 README 文件后，README 就会显示在 GitHub 仓库的首页上。 编写你的贡献指南一份 CONTRIBUTING 文件能否告诉你的粉丝如何参与你的项目。例如，文件中可能会包含如下信息： 如何报告 bug (尽量使用 issue 和 pull request 目标) 如何提议一个新特性 如何建立你的开发环境和运行测试 另外技术清单和一份 CONTRIBUTING 文件是一个你向贡献者传达你的期望的机会。如： 你渴望得到什么类型的贡献 项目的发展路线或者期望 贡献者应该如何联系你 使用温暖，友好的语气，并提供具体的建议（如写作文档或做一个网站）可以很大程度上让新来者感到欢迎和兴奋参与。 例如，Active Admin starts its contributing guide with: 首先，感谢你考虑为 Active Admin 做贡献。就是因为有了像您这样的人让 Active Admin 成为了一个伟大的工具。 在项目的早期，你的 CONTRIBUTING 文件会比较简单。为了做出贡献，你应该总是解释如何报告 bugs 或者文件 issues 和一些技术要求（像测试）。 过了一段时间，你肯会把频繁出现的提问添加到 CONTRIBUTING 文件中。写下这些信息意味着会有更少的人再重复向你提相同的问题。 想获得更多书写 CONTRIBUTING 文件的帮助，请查阅 @nayafia’s 贡献指南模板 or @mozilla’s “如何创建 CONTRIBUTING.md”. 在 README 中附上 CONTRIBUTING 文件的链接，这样会让跟多的人看到。如果你 将 CONTRIBUTING 文件放在项目的仓库中,GitHub 会自动链接你的文件当贡献者创建一条issue或者打开一个 pull request。 制定行为规则 我们有过这样的经历，我们面临什么是滥用，或者作为一名维护者试图解释为什么有些事必须按一定的方式，或者作为一名用户提出简单的问题。(…) 一份行为规则会变成一份简单的参考和可链接的表示你的团队提出的建设性的话语非常认真的文档。 — @mlynch, “Making Open Source a Happier Place” 最后，一份行为规则帮助你为你项目的参与者建立了行为准则。如果你为一个社区或者一家公司发起一个开源项目，它是非常有价值的。一份行为规则授权你促成健康，有建设性的社区行为，这回减轻你作为一名维护者的压力。 想获得更多信息，请查阅我们的 行为规则指南. 除了沟通如何期望参与者行为之外，行为准则还倾向于描述这些期望适用于谁，何时应用，以及如果违规发生时该做什么。 许多开源协议一般也会为行为规则制定标准，所以你可以不用再编写。这份贡献者盟约 是一份被超过40,000个开源项目所使用的行为规则，包括 Kubernetes, Rails 和 Swift。无论你使用哪个文本，在必要的时候你都应该执行你的行为规则。 将文本直接粘贴到你仓库中的 CODE_OF_CONDUCT 文件中。将文件放在项目的根目录中方便查找，同时在 README 中添加相应的链接。 命名和品牌化你的项目品牌不仅是一个华丽的 logo 或者易记的项目名。它还关于你如何谈论你的项目，以及你想把信息传递给谁。 选择正确的名字选择一个容易记住，有创意，能表达项目用意的名字。例如： Sentry 监控应用程序的崩溃报告 Thin 是一个简单快速的 Ruby web 服务器。 如果你的项目是基于一个已存在的项目创建，那么使用他们的名字作为你项目名的前缀会帮助你阐述你项目的用途。 (例如 node-fetch将window.fetch 添加到了 Node.js)。 考虑阐明所有。押韵虽然有趣，但是记住玩笑不可能转变成其它的文化，或者他人与你有不同的经历。你的一些潜在用户可能是公司员工，你不能让他们在工作中很难解释你的项目！ 避免命名冲突查看是否有同名的开源项目，尤其是你分享的是同样的语言或者生态系统。如果你的名字与一个已存在的知名的项目有冲突，你会让你的粉丝感到困惑。 如果你想要一个网站，Twitter 账号或者其他特性来展示你的项目，先确保你能得到你想要的名字。理想情况下，为了美好的未来现在保留这些名字，即使你现在不想用他们。 确保你的项目名没有侵权。如果有侵权，可能会有公司要求你的项目下架，或者对你采取法律措施。这样得不偿失。 你可以查阅WIPO全球品牌数据库避免商标冲突。如果你是在公司工作，法律团队会帮你做这件事。 最后，去谷歌搜索你的项目名。大家会很容易地找到你的项目吗？在搜索结果礼是否有你不想让大家看到的东西？ 你的写作（和代码）如何影响你的品牌在项目的整个生命周期中，你需要做很多文字工作：READMEs，教程，社区文档，回复 issues，甚至肯能要处理很多来信和邮件。 是否是官方文档或者一封普通的邮件，你的书写风格都是你项目品牌的一部分。考虑你可能会拥有粉丝，以及这是你想传达的声音。 我尝试处理每一个细节，包括：处理邮件，展示示例，友好待人，认真处理大家的 issues 以及试图帮助到大家。经过一段时间后，大家可能不再是只问问题，还会帮助我解决其他人的疑问以及给我喜悦，他们模仿我的风格。 — @janl on CouchDB, “Sustainable Open Source” 使用热情，通俗易懂的语言（如“他们”，即使是指一个人）能够让新来的贡献者感觉项目非常欢迎他们。使用简单的语言，因为你的读者可能英语不是很好。 除了书写风格外，你的编码风格也是你项目品牌的一部分。 Angular 和 jQuery是两个项目代码风格严谨的示例和指南。 当你的项目才开始时，没有必要为项目编写一份风格指南。你可能会发现你喜欢将不同的编码风格融入到项目。但是你应该想到你的书写和编码风格会吸引或者拒绝不同类型的人。项目的早期是你建立你希望看见的先例的机会。 你的预发布清单准备好开源你的项目了吗？有一份帮助检查清单。检查所有内容？你准备开始吧！ 点击 “publish” 以及拍下自己的后背。 文档 需要为项目指定一个开源协议 项目要有基础文档 (README, CONTRIBUTING, CODE_OF_CONDUCT) 易记的项目名，指出项目是做什么的，不能和已存在的项目冲突或者商标侵权 最新的 issue 队列，组织和标记清除的 issues 代码 项目使用一致的代码风格和明确的功能/方法/可用的名字 注释清晰的代码，记录意图和边缘案例 在修改历史，issues 或者 pull requests 中没有敏感的信息 (例如 密码或者其他不能公开的信息) 人 如果你是代表个人： 你已经告诉了你的法律部门，以及/或者理解了你公司（如果你是某一家公司的员工）的开源政策和 IP 如果你有一家公司或者组织： 你已经告诉了你的法律部门 你有一个宣布和促进项目的营销计划 一些人被允许管理社区互动（回复 issues，检查和合并 pull requests） 至少有两人管理访问项目 你做到了！恭喜你开源了你的首个项目。不论结果如何，对开源社区都是一份礼物。随着每次 commit,comment 和 pull request，你正在为自己或者他人创造学习和成长的机会。GitHub 开源项目贡献指南中文版：https://github.com/liadbiz/opensource-contribute-guide-chinise 英文版：https://opensource.guide","tags":[{"name":"GitHub","slug":"GitHub","permalink":"http://yoursite.com/tags/GitHub/"}]},{"title":"学编程，先知规范","date":"2018-03-22T16:19:44.000Z","path":"2018/03/23/学编程，先知规范/","text":"我为什么要写这篇博客写博客一直是我想去做的事，可是一直没有付诸于行动。虽然看别人的博客很容易，但当自己开始在键盘上敲打的时候，我发现太痛苦了。 2017 年 8 月初，和我同一批校招进厂的同学们都已上岗工作了。因为我们的水平不太统一，有的基础好点，有的基础差点，所以老大每周会给我们布置作业，同时也会对我们的作业进行讲评。经过最近两次作业，我发现有部分同学的编码规范有待提高。其实这也可以理解，因为他们之前没有接触过，在学校的时候也没人告诉他们编码要讲究规范。 我是四月份进的厂，老大安排我维护两个系统。当我看见系统的源码的时候，我的心里有着一万匹叫做曹里的马在奔腾。包含几百行代码的方法随处可见；一个方法有几十个形式参数是正常现象；各种代码风格混杂在一起特别杀马特；在 JSP 里掺杂着 Java、JS、HTML、CSS 代码，有种 56 个民族一家亲的味道；整个系统有一半的逻辑是写在存储过程里的，先喝口水压压惊。 其实公司老系统代码令人恶心的一个很重要的原因就是上梁不正，下梁歪。由于刚进来的新人也不分不清代码风格的好坏，他们只能学着前人的风格。这样的恶性循环非常可怕。我希望所有学习编程的同学，从开始就养成一个非常好地编码习惯。 高级程序语言诞生的目的我们现在接触到的绝大多数编程语言都是高级语言，例如： C、C++、Java、JavaScript 等。我们在这里不论各种高级程序语言的优劣。 我们一定要铭记，用高级语言写出来的代码是给人看的。我相信高级语言诞生时最宏伟的一个目标就是：即使没有学过编程的人，他们可以通过类名、方法名和变量名大概知道程序的功能。 像写好一篇文章一样写代码我相信一篇优秀的文章，一定是内容精彩，同时字迹漂亮，文章格式人性化。如果一篇文章的内容非常的不错，但是作者的字及其丑陋，同时文章的格式乱糟糟的。我相信那依然是一篇没人喜欢看的天书。写代码也是同样的道理，即使你的代码所实现的功能非常牛逼，但我们这些凡夫俗子都看不懂，那你的代码也没有多大的价值。 我们简单看一下写出好代码要掌握哪些规范： 每个方法所能容纳的代码行数不要超过 30 行，一行代码的字符数量控制在 120 以内。 一个方法只做一件事， 就好比我们在家只吃饭，却不做饭。 在给类名、方法名和变量命名时尽量做到见名知意，这会比你们的注释更加给力，因为这时你们的代码自带注释功效。 类名的每个单词的首字母大写；方法名和变量名的第一个单词的首字母小写，后面单词的首字母大写，这就是传说中的驼峰命名法；常量名的所有字母都要大写，并且每个单词间用下划线隔开。 如果一个方法的形式参数中有太多的基本类型，或者数量超过了 5 个，这时你可以将这些参数封装成一个类。 当一个方法的逻辑比较复杂的时候，一定要加上注释；给类加上注释，以阐明一个类有哪些功能。 我们也是自己嘴中的那个坑货如果你们觉得养成良好的编码习惯并不重要，或者是很难。那么你们可以时隔一个月、半年或者一年再去看你们之前写过的代码，我相信你们会喷嚏连连，因为你们会骂这是哪个傻*写的，很不幸那个傻坑货就是你们自己。 不要抱着侥幸的心态，自以为只要是自己写的代码自己就能看懂。其实，你们写的代码并不是你们自己的，随着时间的推移，你们的代码就是别人的啦。为了不让别人(包括你们自己)在背后骂你们，一定要养成良好的编码习惯。 总结我在文章中并没有详细地列举具体地编码规则，因为这些规则已经有人给出来了。阿里巴巴为我们贡献了一套 Java 开发规范，这套规范不仅适用于 Java 开发，同样对其他的编程开发有借鉴意义。这里是阿里巴巴 Java 开发手册的下载地址。[PS： 阿里巴巴的 Java 开发团队是国内最牛逼的] 最后我给大家推荐一本非常好的书[编写可读代码的艺术]，它会教你如何写出一手漂亮的代码，在书中有各种编程语言的实例。","tags":[{"name":"编程规范","slug":"编程规范","permalink":"http://yoursite.com/tags/编程规范/"}]},{"title":"设计模式笔记——观察者模式","date":"2018-03-22T16:00:01.000Z","path":"2018/03/23/设计模式笔记——观察者模式/","text":"什么是观察者模式（Observer Pattern）观察者模式定义了对象之间的一对多依赖。这样一来，当一个对象状态改变时它的所有依赖者都会收到通知并自动更新。 观察者模式的应用观察者模式的应用很广泛。例如在 Android 开发时需要对控件注册事件监听，控件属于被观察者，在该控件上所注册的事件属于观察者，当控件发生变化时相应的监听事件会立即做出回应。我想大家都有自己喜欢的微信公众号，其实微信公众号的订阅、推送很好的体现了观察者模式。当我们想及时获得自己喜欢的公号的更新就得先关注它，然后公号有更新时会第一时间通知它的每一位仰慕者。设计模式来源于生活，细细品味生活能够更好的去理解设计模式。 观察者模式所涉及的 OO 设计原则 实现交互对象之间的松耦合。 何为对象之间的松耦合？松耦合就是两个对象可以交互，但是不太清楚彼此的细节。更通俗一点来说就是你和你的手机就是松耦合的，你可以很轻松的玩耍你的手机（你和手机进行者交互），但你并知道手机内部的实现，手机也更不知道使用者是谁啦。 封装变化。 多用组合，少用继承。 针对接口编程，不针对实现编程。 观察者模式 Java 代码实现及分析 分析 此 Demo 借用模拟微信公众号简单地实现了观察者模式。 WeChatPublicNumber 是所有微信公众号的公共接口，所有具体的微信公众号都要实现此接口，CnboJavaDev 就是一个实现此接口的微信公众号（我决定了，我以后的微信公众号就叫此名了，嘻嘻）。WeChatPublicNumber 提供了用户订阅 registerUser(User user) 和取消订阅的方法 removeUser(User user)，还有推送更新的方法 notifyUsers()。 User 是所有用户的公共接口，此接口提供了更新方法 update() 和文章阅读方法 readArticle() (此方法主要用来测试打印)。Facebook 和 Google 实现了 User 接口。 TestObserver 用于对此 Demo 的测试。 Demo 的 UML 类图 WeChatPublicNumber.java 1234567891011//WeChatPublicNumber(微信公众号接口)public interface WeChatPublicNumber &#123; //用户订阅公号 public void registerUser(User user); //用户取消订阅 public void removeUser(User user); //向所有订阅用户推送更新 public void notifyUsers();&#125; Article.java 1234567891011121314151617181920212223242526272829//文章(别乱想哦)public class Article &#123; //文章的标题 private String title; //文章的作者 private String author; public String getTitle() &#123; return title; &#125; public void setTitle(String title) &#123; this.title = title; &#125; public String getAuthor() &#123; return author; &#125; public void setAuthor(String author) &#123; this.author = author; &#125; @Override public String toString() &#123; return \"title:\" + title + \"; author:\" + author; &#125;&#125; User.java 123456//微信用户接口public interface User &#123; public void update(Article article); public void readAritcle();&#125; CnboJavaDev.java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546//CnboJavaDev 是一个实现了接口 WeChatPublicNumberpublic class CnboJavaDev implements WeChatPublicNumber &#123; private Article article; private List&lt;User&gt; users; public CnboJavaDev() &#123; users = new ArrayList&lt;&gt;(); &#125; @Override public void registerUser(User user) &#123; if (users != null) &#123; users.add(user); &#125; &#125; @Override public void removeUser(User user) &#123; if (users != null &amp;&amp; users.contains(user)) &#123; users.remove(user); &#125; &#125; //发布文章 public void publishArticle() &#123; notifyUsers(); &#125; //向所有订阅者推送文章 @Override public void notifyUsers() &#123; if (users == null) &#123; return; &#125; for (User user : users) &#123; user.update(article); user.readAritcle(); &#125; &#125; public void addArticle(Article article) &#123; this.article = article; publishArticle(); &#125;&#125; Facebook.java 1234567891011121314151617181920//微信用户 Facebookpublic class Facebook implements User &#123; private Article article; private WeChatPublicNumber weChatPublicNumber; public Facebook(WeChatPublicNumber weChatPublicNumber) &#123; this.weChatPublicNumber = weChatPublicNumber; weChatPublicNumber.registerUser(this); &#125; @Override public void update(Article article) &#123; this.article = article; &#125; @Override public void readAritcle() &#123; System.out.println(\"facebook read \" + article); &#125;&#125; Google.java 1234567891011121314151617181920//微信用户 Googlepublic class Google implements User &#123; private Article article; private WeChatPublicNumber weChatPublicNumber; public Google(WeChatPublicNumber weChatPublicNumber) &#123; this.weChatPublicNumber = weChatPublicNumber; weChatPublicNumber.registerUser(this); &#125; @Override public void update(Article article) &#123; this.article = article; &#125; @Override public void readAritcle() &#123; System.out.println(\"google read \" + article); &#125;&#125; TestObserver.java 123456789101112131415161718192021222324//测试观察者模式public class TestObserver &#123; public static void main(String[] args) &#123; CnboJavaDev cnboJavaDev = new CnboJavaDev(); //facebook 和 google 关注了 cnboJavaDev（如果我真被 facebook 和 google //关注了，那我会兴奋成神经的，哈哈） User facebook = new Facebook(cnboJavaDev); User google = new Google(cnboJavaDev); Article article1 = getArticle(\"学习笔记之单例设计模式\", \"cnbo\"); //cnboJavaDev 发布一篇新文章 article1，同时 facebook 和 google //都接收到了更新，然后他哥俩有滋有味的读者cnbo的文章。 cnboJavaDev.addArticle(article1); Article article2 = getArticle(\"学习笔记之策略设计模式\", \"cnbo\"); cnboJavaDev.addArticle(article2); &#125; public static Article getArticle(String title, String author) &#123; Article article = new Article(); article.setTitle(title); article.setAuthor(author); return article; &#125;&#125;","tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/设计模式/"}]},{"title":"设计模式笔记——策略设计模式","date":"2018-03-22T15:51:11.000Z","path":"2018/03/22/设计模式笔记——策略设计模式/","text":"什么是策略设计模式策略设计模式（Strategy Pattern）：定义了算法族，分别封装起来，让他们之间可以互相替换，此模式让算法的变化独立于使用算法的客户。其实策略设计模式的核心就是多态（变量的声明是一个超类型，通常是一个抽象类或一个接口，在程序运行时根据情况选择具体要执行的行为。） 策略模式的应用 多个类拥有相同的方法，但具体的实现方式不同，在运行时动态地选择具体要执行的行为。 需要在不同情况下使用不同策略（算法），或则策略在未来还可能使用其他方式实现。 对客户隐藏具体策略的实现细节，彼此完全独立。 策略设计模式涉及的 OO 设计原则 找出应用中可能需要变化之处，把他们独立出来，不要和那些不需要变化的代码混在一起。 针对接口编程，而不是针对实现编程。 “ 针对接口编程”真正意思是“针对超类型编程”，关键就在多态。 多用组合，少用继承。 策略模式 Java 代码实现及分析 Demo 的 UML 图 ProgrammingLanguage.java 123public interface ProgrammingLanguage &#123; public void program();&#125; Java.java 123456public class Java implements ProgrammingLanguage &#123; @Override public void program() &#123; System.out.println(\"use java programming\"); &#125;&#125; JavaScript.java 123456public class JavaScript implements ProgrammingLanguage &#123; @Override public void program() &#123; System.out.println(\"use JavaScript programming\"); &#125;&#125; ObjectC.java 123456public class ObjectC implements ProgrammingLanguage &#123; @Override public void program() &#123; System.out.println(\"use ObjectC programming\"); &#125;&#125; Programmer.java 12345678910111213public abstract class Programmer &#123; ProgrammingLanguage language; public void performProgram() &#123; language.program(); &#125; //动态地指定程序员所使用的编程语言，比如java程序也也需要使用JavaScript编写程序 public void setProgrammiingLanguage ( ProgrammingLanguage language) &#123; this.language = language; &#125;&#125; JavaProgrammer.java 123456public class JavaProgrammer extends Programmer &#123; //构造Java程序员时预指定其所擅长的编程语言 public JavaProgrammer(ProgrammingLanguage language) &#123; this.language = language; &#125;&#125; JavaScriptProgrammer.java 123456public class JavaScriptProgrammer extends Programmer &#123; //在构造JavaScript程序员时预指定其所擅长的编程语言 public JavaScriptProgrammer(ProgrammingLanguage language) &#123; this.language = language; &#125;&#125; 分析此 Demo 简单的实现了策略设计模式。实现的代码我已经在上面贴出，现在我说说代码背后的故事。 我是如何实现“针对接口编程”的Programmer 是将 performProgram() 的实现委托给接口 ProgrammingLanguage 的，而不是直接委托给 ProgrammingLanguage 的实现类。Programmer 的子类并不用关心 ProgrammingLanguage 的子类是如何实现的，他们之间是松耦合的。 我是如何实现“封装变化”的Programmer (程序员)使用那一种 language (编程语言)编程是不确定的，是可以动态变化的。所以我将具体的编程方法 program() 封装在了 ProgrammingLanguage 中了，即 Programmer 中performPrograme() 的具体执行是 language.program()。由于 language 是一个接口类型的引用变量，所以 Programmer 的子类在程序运行过程中通过 setProgrammingLanguage 方法动态改变真正要使用的 ProgrammingLanguage 的实现类。 我是如哦哦和实现“多用组合，少用继承”的由于 Programmer 使用的 language 是动态变化的，所以我在 Programmer 声明了一个接口类型的引用变量 language，而不是选择在 Programmer 的子类中通过实现各种接口获得使用某种编程语言的能力。","tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/设计模式/"}]},{"title":"设计模式笔记——单例设计模式","date":"2018-03-22T15:22:34.000Z","path":"2018/03/22/设计模式笔记——单例设计模式/","text":"什么是单例模式（Singleton Pattern）单例模式确保一个类只有一个实例，并提供一个全局访问点。 单例模式的应用场景实现一个单例模式很简单，但我没有想过单例模式有什么用处，直到一次笔试就遇到了问单利模式的应用场景有哪些。 单例模式的应用场景：线程池（Thread Pool）、缓存（Cache）、对话框、处理偏好设置、注册表（Registry）对象，日志对象，充当打印机、显卡等设备的驱动程序的对象。这类对象只能有一个对象，如果出现多个实例就会导致很多问题，例如：程序的行为异常、资源使用过量、或者是出现不一致的结果。 Java 代码实现单例有四种方式实现单例模式，分别是：饿汉式、懒汉式、双重检查加锁、枚举。接下来我会结合代码介绍这四种方式。 饿汉式在类被加载时就在类中创建一个唯一实例。优点：线程安全。代码实现： 12345678910111213//单例模式（饿汉式实现）public class Singleton1 &#123; //定义一个静态的Singleton1实例 private static final Singleton1 singleton = new Singleton1(); //私有化构造函数以致外部无法创建 Singleton1 实例 private Singleton1() &#123;&#125; //提供一个静态方法供外部使用 Singleton1 实例 public static Singleton1 getInstance() &#123; return singleton; &#125;&#125; 懒汉式在类首次被使用时才创建处一个全局唯一的实例。缺点：线程不安全。代码实现： 12345678910111213141516// 单例模式（懒汉式实现）public class Singleton2 &#123; private static Singleton2 singleton; //私有化构造函数 private Singleton2() &#123;&#125; public static Singleton2 getInstance() &#123; //判断 singleton 是否为 null,如果为 null 则创建，否则直接返回 if (singleton == null) &#123; singleton = new Singleton2(); &#125; return singleton; &#125;&#125; 双重检查加锁双重检查加锁是对饿汉式在多线程环境下的升级，保证其线程安全。之所以在代码中是用双检查是为了确保只有在第一次创建实例时才会使用同步，因为同步非常的耗资源。代码实现： 12345678910111213141516171819// 单例模式（线程同步实现）public class Singleton3 &#123; private static Singleton3 singleton; private Singleton3() &#123;&#125; public static Singleton3 getInstance() &#123; //双重检查加锁 if (singleton == null) &#123; synchronized(Singleton3.class) &#123; if (singleton == null) &#123; singleton = new Singleton3(); &#125; &#125; &#125; return singleton; &#125;&#125; 枚举枚举是最优雅的实现单例的方式。饿汉式、懒汉式、双重检查加锁都有一个共同 的问题，那就是都可以通过反射机制调用私有构造器创建实例，这样就不能保证实例是唯一的，这有背单例的使命了。同时枚举也是线程安全的。代码实现： 1234// 单例模式（枚举实现）public enum Singleton4 &#123; INSTANCE;&#125; 是不是觉得枚举实现单例的代码太简单了，我想说的是，枚举就是这么任性，就是要这么简单。 FAQ 为什么全局变量比单例模式差全局变量基本上是对对象的静态引用。在这样的情况下使用全局变量非常耗资源。同时使用全局变量不能确保只有一个实例。 单例类能否被继承无论是枚举实现还是非枚举实现，单例类都不能被继承。非枚举方式实现的单例类由于构造器是私有的，因而不能被继承。 单例是否违背例 OO 设计答案是肯定的。单例类不只负责管理自己的实例，同时还在应用程序中担任角色。虽然单例违背例 OO 设计，但它让整体设计变得简单，这是可以谅解的。 有多个类加载器的情况下如何处理单例类自行指定类加载器，并指定同一个类加载器。","tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/设计模式/"}]}]